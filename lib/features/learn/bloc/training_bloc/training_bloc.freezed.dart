// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'training_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$TrainingState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(String message) failed,
    required TResult Function(ValueKey<dynamic> valueKey, WordModel word)
        screen1,
    required TResult Function(ValueKey<dynamic> valueKey, WordModel word,
            List<Pair<String, int>> letters)
        screen2,
    required TResult Function(ValueKey<dynamic> valueKey, WordModel word)
        screen3,
    required TResult Function(ValueKey<dynamic> valueKey, bool cantHear,
            WordModel word, List<WordModel> selectableWords)
        screen4,
    required TResult Function() finalScreen,
    required TResult Function() zeroHealthScreen,
    required TResult Function(WordModel word) success,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(String message)? failed,
    TResult? Function(ValueKey<dynamic> valueKey, WordModel word)? screen1,
    TResult? Function(ValueKey<dynamic> valueKey, WordModel word,
            List<Pair<String, int>> letters)?
        screen2,
    TResult? Function(ValueKey<dynamic> valueKey, WordModel word)? screen3,
    TResult? Function(ValueKey<dynamic> valueKey, bool cantHear, WordModel word,
            List<WordModel> selectableWords)?
        screen4,
    TResult? Function()? finalScreen,
    TResult? Function()? zeroHealthScreen,
    TResult? Function(WordModel word)? success,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(String message)? failed,
    TResult Function(ValueKey<dynamic> valueKey, WordModel word)? screen1,
    TResult Function(ValueKey<dynamic> valueKey, WordModel word,
            List<Pair<String, int>> letters)?
        screen2,
    TResult Function(ValueKey<dynamic> valueKey, WordModel word)? screen3,
    TResult Function(ValueKey<dynamic> valueKey, bool cantHear, WordModel word,
            List<WordModel> selectableWords)?
        screen4,
    TResult Function()? finalScreen,
    TResult Function()? zeroHealthScreen,
    TResult Function(WordModel word)? success,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_TrainingInitial value) initial,
    required TResult Function(_TrainingIsLoading value) loading,
    required TResult Function(_TrainingFailed value) failed,
    required TResult Function(_Screen1 value) screen1,
    required TResult Function(_Screen2 value) screen2,
    required TResult Function(_Screen3 value) screen3,
    required TResult Function(_Screen4 value) screen4,
    required TResult Function(_FinalScreen value) finalScreen,
    required TResult Function(_ZeroHealthScreen value) zeroHealthScreen,
    required TResult Function(_Success value) success,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_TrainingInitial value)? initial,
    TResult? Function(_TrainingIsLoading value)? loading,
    TResult? Function(_TrainingFailed value)? failed,
    TResult? Function(_Screen1 value)? screen1,
    TResult? Function(_Screen2 value)? screen2,
    TResult? Function(_Screen3 value)? screen3,
    TResult? Function(_Screen4 value)? screen4,
    TResult? Function(_FinalScreen value)? finalScreen,
    TResult? Function(_ZeroHealthScreen value)? zeroHealthScreen,
    TResult? Function(_Success value)? success,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_TrainingInitial value)? initial,
    TResult Function(_TrainingIsLoading value)? loading,
    TResult Function(_TrainingFailed value)? failed,
    TResult Function(_Screen1 value)? screen1,
    TResult Function(_Screen2 value)? screen2,
    TResult Function(_Screen3 value)? screen3,
    TResult Function(_Screen4 value)? screen4,
    TResult Function(_FinalScreen value)? finalScreen,
    TResult Function(_ZeroHealthScreen value)? zeroHealthScreen,
    TResult Function(_Success value)? success,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TrainingStateCopyWith<$Res> {
  factory $TrainingStateCopyWith(
          TrainingState value, $Res Function(TrainingState) then) =
      _$TrainingStateCopyWithImpl<$Res, TrainingState>;
}

/// @nodoc
class _$TrainingStateCopyWithImpl<$Res, $Val extends TrainingState>
    implements $TrainingStateCopyWith<$Res> {
  _$TrainingStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$TrainingInitialImplCopyWith<$Res> {
  factory _$$TrainingInitialImplCopyWith(_$TrainingInitialImpl value,
          $Res Function(_$TrainingInitialImpl) then) =
      __$$TrainingInitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$TrainingInitialImplCopyWithImpl<$Res>
    extends _$TrainingStateCopyWithImpl<$Res, _$TrainingInitialImpl>
    implements _$$TrainingInitialImplCopyWith<$Res> {
  __$$TrainingInitialImplCopyWithImpl(
      _$TrainingInitialImpl _value, $Res Function(_$TrainingInitialImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$TrainingInitialImpl implements _TrainingInitial {
  const _$TrainingInitialImpl();

  @override
  String toString() {
    return 'TrainingState.initial()';
  }

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(String message) failed,
    required TResult Function(ValueKey<dynamic> valueKey, WordModel word)
        screen1,
    required TResult Function(ValueKey<dynamic> valueKey, WordModel word,
            List<Pair<String, int>> letters)
        screen2,
    required TResult Function(ValueKey<dynamic> valueKey, WordModel word)
        screen3,
    required TResult Function(ValueKey<dynamic> valueKey, bool cantHear,
            WordModel word, List<WordModel> selectableWords)
        screen4,
    required TResult Function() finalScreen,
    required TResult Function() zeroHealthScreen,
    required TResult Function(WordModel word) success,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(String message)? failed,
    TResult? Function(ValueKey<dynamic> valueKey, WordModel word)? screen1,
    TResult? Function(ValueKey<dynamic> valueKey, WordModel word,
            List<Pair<String, int>> letters)?
        screen2,
    TResult? Function(ValueKey<dynamic> valueKey, WordModel word)? screen3,
    TResult? Function(ValueKey<dynamic> valueKey, bool cantHear, WordModel word,
            List<WordModel> selectableWords)?
        screen4,
    TResult? Function()? finalScreen,
    TResult? Function()? zeroHealthScreen,
    TResult? Function(WordModel word)? success,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(String message)? failed,
    TResult Function(ValueKey<dynamic> valueKey, WordModel word)? screen1,
    TResult Function(ValueKey<dynamic> valueKey, WordModel word,
            List<Pair<String, int>> letters)?
        screen2,
    TResult Function(ValueKey<dynamic> valueKey, WordModel word)? screen3,
    TResult Function(ValueKey<dynamic> valueKey, bool cantHear, WordModel word,
            List<WordModel> selectableWords)?
        screen4,
    TResult Function()? finalScreen,
    TResult Function()? zeroHealthScreen,
    TResult Function(WordModel word)? success,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_TrainingInitial value) initial,
    required TResult Function(_TrainingIsLoading value) loading,
    required TResult Function(_TrainingFailed value) failed,
    required TResult Function(_Screen1 value) screen1,
    required TResult Function(_Screen2 value) screen2,
    required TResult Function(_Screen3 value) screen3,
    required TResult Function(_Screen4 value) screen4,
    required TResult Function(_FinalScreen value) finalScreen,
    required TResult Function(_ZeroHealthScreen value) zeroHealthScreen,
    required TResult Function(_Success value) success,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_TrainingInitial value)? initial,
    TResult? Function(_TrainingIsLoading value)? loading,
    TResult? Function(_TrainingFailed value)? failed,
    TResult? Function(_Screen1 value)? screen1,
    TResult? Function(_Screen2 value)? screen2,
    TResult? Function(_Screen3 value)? screen3,
    TResult? Function(_Screen4 value)? screen4,
    TResult? Function(_FinalScreen value)? finalScreen,
    TResult? Function(_ZeroHealthScreen value)? zeroHealthScreen,
    TResult? Function(_Success value)? success,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_TrainingInitial value)? initial,
    TResult Function(_TrainingIsLoading value)? loading,
    TResult Function(_TrainingFailed value)? failed,
    TResult Function(_Screen1 value)? screen1,
    TResult Function(_Screen2 value)? screen2,
    TResult Function(_Screen3 value)? screen3,
    TResult Function(_Screen4 value)? screen4,
    TResult Function(_FinalScreen value)? finalScreen,
    TResult Function(_ZeroHealthScreen value)? zeroHealthScreen,
    TResult Function(_Success value)? success,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _TrainingInitial implements TrainingState {
  const factory _TrainingInitial() = _$TrainingInitialImpl;
}

/// @nodoc
abstract class _$$TrainingIsLoadingImplCopyWith<$Res> {
  factory _$$TrainingIsLoadingImplCopyWith(_$TrainingIsLoadingImpl value,
          $Res Function(_$TrainingIsLoadingImpl) then) =
      __$$TrainingIsLoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$TrainingIsLoadingImplCopyWithImpl<$Res>
    extends _$TrainingStateCopyWithImpl<$Res, _$TrainingIsLoadingImpl>
    implements _$$TrainingIsLoadingImplCopyWith<$Res> {
  __$$TrainingIsLoadingImplCopyWithImpl(_$TrainingIsLoadingImpl _value,
      $Res Function(_$TrainingIsLoadingImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$TrainingIsLoadingImpl implements _TrainingIsLoading {
  const _$TrainingIsLoadingImpl();

  @override
  String toString() {
    return 'TrainingState.loading()';
  }

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(String message) failed,
    required TResult Function(ValueKey<dynamic> valueKey, WordModel word)
        screen1,
    required TResult Function(ValueKey<dynamic> valueKey, WordModel word,
            List<Pair<String, int>> letters)
        screen2,
    required TResult Function(ValueKey<dynamic> valueKey, WordModel word)
        screen3,
    required TResult Function(ValueKey<dynamic> valueKey, bool cantHear,
            WordModel word, List<WordModel> selectableWords)
        screen4,
    required TResult Function() finalScreen,
    required TResult Function() zeroHealthScreen,
    required TResult Function(WordModel word) success,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(String message)? failed,
    TResult? Function(ValueKey<dynamic> valueKey, WordModel word)? screen1,
    TResult? Function(ValueKey<dynamic> valueKey, WordModel word,
            List<Pair<String, int>> letters)?
        screen2,
    TResult? Function(ValueKey<dynamic> valueKey, WordModel word)? screen3,
    TResult? Function(ValueKey<dynamic> valueKey, bool cantHear, WordModel word,
            List<WordModel> selectableWords)?
        screen4,
    TResult? Function()? finalScreen,
    TResult? Function()? zeroHealthScreen,
    TResult? Function(WordModel word)? success,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(String message)? failed,
    TResult Function(ValueKey<dynamic> valueKey, WordModel word)? screen1,
    TResult Function(ValueKey<dynamic> valueKey, WordModel word,
            List<Pair<String, int>> letters)?
        screen2,
    TResult Function(ValueKey<dynamic> valueKey, WordModel word)? screen3,
    TResult Function(ValueKey<dynamic> valueKey, bool cantHear, WordModel word,
            List<WordModel> selectableWords)?
        screen4,
    TResult Function()? finalScreen,
    TResult Function()? zeroHealthScreen,
    TResult Function(WordModel word)? success,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_TrainingInitial value) initial,
    required TResult Function(_TrainingIsLoading value) loading,
    required TResult Function(_TrainingFailed value) failed,
    required TResult Function(_Screen1 value) screen1,
    required TResult Function(_Screen2 value) screen2,
    required TResult Function(_Screen3 value) screen3,
    required TResult Function(_Screen4 value) screen4,
    required TResult Function(_FinalScreen value) finalScreen,
    required TResult Function(_ZeroHealthScreen value) zeroHealthScreen,
    required TResult Function(_Success value) success,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_TrainingInitial value)? initial,
    TResult? Function(_TrainingIsLoading value)? loading,
    TResult? Function(_TrainingFailed value)? failed,
    TResult? Function(_Screen1 value)? screen1,
    TResult? Function(_Screen2 value)? screen2,
    TResult? Function(_Screen3 value)? screen3,
    TResult? Function(_Screen4 value)? screen4,
    TResult? Function(_FinalScreen value)? finalScreen,
    TResult? Function(_ZeroHealthScreen value)? zeroHealthScreen,
    TResult? Function(_Success value)? success,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_TrainingInitial value)? initial,
    TResult Function(_TrainingIsLoading value)? loading,
    TResult Function(_TrainingFailed value)? failed,
    TResult Function(_Screen1 value)? screen1,
    TResult Function(_Screen2 value)? screen2,
    TResult Function(_Screen3 value)? screen3,
    TResult Function(_Screen4 value)? screen4,
    TResult Function(_FinalScreen value)? finalScreen,
    TResult Function(_ZeroHealthScreen value)? zeroHealthScreen,
    TResult Function(_Success value)? success,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _TrainingIsLoading implements TrainingState {
  const factory _TrainingIsLoading() = _$TrainingIsLoadingImpl;
}

/// @nodoc
abstract class _$$TrainingFailedImplCopyWith<$Res> {
  factory _$$TrainingFailedImplCopyWith(_$TrainingFailedImpl value,
          $Res Function(_$TrainingFailedImpl) then) =
      __$$TrainingFailedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$TrainingFailedImplCopyWithImpl<$Res>
    extends _$TrainingStateCopyWithImpl<$Res, _$TrainingFailedImpl>
    implements _$$TrainingFailedImplCopyWith<$Res> {
  __$$TrainingFailedImplCopyWithImpl(
      _$TrainingFailedImpl _value, $Res Function(_$TrainingFailedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$TrainingFailedImpl(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$TrainingFailedImpl implements _TrainingFailed {
  const _$TrainingFailedImpl({required this.message});

  @override
  final String message;

  @override
  String toString() {
    return 'TrainingState.failed(message: $message)';
  }

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$TrainingFailedImplCopyWith<_$TrainingFailedImpl> get copyWith =>
      __$$TrainingFailedImplCopyWithImpl<_$TrainingFailedImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(String message) failed,
    required TResult Function(ValueKey<dynamic> valueKey, WordModel word)
        screen1,
    required TResult Function(ValueKey<dynamic> valueKey, WordModel word,
            List<Pair<String, int>> letters)
        screen2,
    required TResult Function(ValueKey<dynamic> valueKey, WordModel word)
        screen3,
    required TResult Function(ValueKey<dynamic> valueKey, bool cantHear,
            WordModel word, List<WordModel> selectableWords)
        screen4,
    required TResult Function() finalScreen,
    required TResult Function() zeroHealthScreen,
    required TResult Function(WordModel word) success,
  }) {
    return failed(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(String message)? failed,
    TResult? Function(ValueKey<dynamic> valueKey, WordModel word)? screen1,
    TResult? Function(ValueKey<dynamic> valueKey, WordModel word,
            List<Pair<String, int>> letters)?
        screen2,
    TResult? Function(ValueKey<dynamic> valueKey, WordModel word)? screen3,
    TResult? Function(ValueKey<dynamic> valueKey, bool cantHear, WordModel word,
            List<WordModel> selectableWords)?
        screen4,
    TResult? Function()? finalScreen,
    TResult? Function()? zeroHealthScreen,
    TResult? Function(WordModel word)? success,
  }) {
    return failed?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(String message)? failed,
    TResult Function(ValueKey<dynamic> valueKey, WordModel word)? screen1,
    TResult Function(ValueKey<dynamic> valueKey, WordModel word,
            List<Pair<String, int>> letters)?
        screen2,
    TResult Function(ValueKey<dynamic> valueKey, WordModel word)? screen3,
    TResult Function(ValueKey<dynamic> valueKey, bool cantHear, WordModel word,
            List<WordModel> selectableWords)?
        screen4,
    TResult Function()? finalScreen,
    TResult Function()? zeroHealthScreen,
    TResult Function(WordModel word)? success,
    required TResult orElse(),
  }) {
    if (failed != null) {
      return failed(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_TrainingInitial value) initial,
    required TResult Function(_TrainingIsLoading value) loading,
    required TResult Function(_TrainingFailed value) failed,
    required TResult Function(_Screen1 value) screen1,
    required TResult Function(_Screen2 value) screen2,
    required TResult Function(_Screen3 value) screen3,
    required TResult Function(_Screen4 value) screen4,
    required TResult Function(_FinalScreen value) finalScreen,
    required TResult Function(_ZeroHealthScreen value) zeroHealthScreen,
    required TResult Function(_Success value) success,
  }) {
    return failed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_TrainingInitial value)? initial,
    TResult? Function(_TrainingIsLoading value)? loading,
    TResult? Function(_TrainingFailed value)? failed,
    TResult? Function(_Screen1 value)? screen1,
    TResult? Function(_Screen2 value)? screen2,
    TResult? Function(_Screen3 value)? screen3,
    TResult? Function(_Screen4 value)? screen4,
    TResult? Function(_FinalScreen value)? finalScreen,
    TResult? Function(_ZeroHealthScreen value)? zeroHealthScreen,
    TResult? Function(_Success value)? success,
  }) {
    return failed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_TrainingInitial value)? initial,
    TResult Function(_TrainingIsLoading value)? loading,
    TResult Function(_TrainingFailed value)? failed,
    TResult Function(_Screen1 value)? screen1,
    TResult Function(_Screen2 value)? screen2,
    TResult Function(_Screen3 value)? screen3,
    TResult Function(_Screen4 value)? screen4,
    TResult Function(_FinalScreen value)? finalScreen,
    TResult Function(_ZeroHealthScreen value)? zeroHealthScreen,
    TResult Function(_Success value)? success,
    required TResult orElse(),
  }) {
    if (failed != null) {
      return failed(this);
    }
    return orElse();
  }
}

abstract class _TrainingFailed implements TrainingState {
  const factory _TrainingFailed({required final String message}) =
      _$TrainingFailedImpl;

  String get message;
  @JsonKey(ignore: true)
  _$$TrainingFailedImplCopyWith<_$TrainingFailedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Screen1ImplCopyWith<$Res> {
  factory _$$Screen1ImplCopyWith(
          _$Screen1Impl value, $Res Function(_$Screen1Impl) then) =
      __$$Screen1ImplCopyWithImpl<$Res>;
  @useResult
  $Res call({ValueKey<dynamic> valueKey, WordModel word});
}

/// @nodoc
class __$$Screen1ImplCopyWithImpl<$Res>
    extends _$TrainingStateCopyWithImpl<$Res, _$Screen1Impl>
    implements _$$Screen1ImplCopyWith<$Res> {
  __$$Screen1ImplCopyWithImpl(
      _$Screen1Impl _value, $Res Function(_$Screen1Impl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? valueKey = null,
    Object? word = null,
  }) {
    return _then(_$Screen1Impl(
      valueKey: null == valueKey
          ? _value.valueKey
          : valueKey // ignore: cast_nullable_to_non_nullable
              as ValueKey<dynamic>,
      word: null == word
          ? _value.word
          : word // ignore: cast_nullable_to_non_nullable
              as WordModel,
    ));
  }
}

/// @nodoc

class _$Screen1Impl implements _Screen1 {
  const _$Screen1Impl({required this.valueKey, required this.word});

  @override
  final ValueKey<dynamic> valueKey;
  @override
  final WordModel word;

  @override
  String toString() {
    return 'TrainingState.screen1(valueKey: $valueKey, word: $word)';
  }

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Screen1ImplCopyWith<_$Screen1Impl> get copyWith =>
      __$$Screen1ImplCopyWithImpl<_$Screen1Impl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(String message) failed,
    required TResult Function(ValueKey<dynamic> valueKey, WordModel word)
        screen1,
    required TResult Function(ValueKey<dynamic> valueKey, WordModel word,
            List<Pair<String, int>> letters)
        screen2,
    required TResult Function(ValueKey<dynamic> valueKey, WordModel word)
        screen3,
    required TResult Function(ValueKey<dynamic> valueKey, bool cantHear,
            WordModel word, List<WordModel> selectableWords)
        screen4,
    required TResult Function() finalScreen,
    required TResult Function() zeroHealthScreen,
    required TResult Function(WordModel word) success,
  }) {
    return screen1(valueKey, word);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(String message)? failed,
    TResult? Function(ValueKey<dynamic> valueKey, WordModel word)? screen1,
    TResult? Function(ValueKey<dynamic> valueKey, WordModel word,
            List<Pair<String, int>> letters)?
        screen2,
    TResult? Function(ValueKey<dynamic> valueKey, WordModel word)? screen3,
    TResult? Function(ValueKey<dynamic> valueKey, bool cantHear, WordModel word,
            List<WordModel> selectableWords)?
        screen4,
    TResult? Function()? finalScreen,
    TResult? Function()? zeroHealthScreen,
    TResult? Function(WordModel word)? success,
  }) {
    return screen1?.call(valueKey, word);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(String message)? failed,
    TResult Function(ValueKey<dynamic> valueKey, WordModel word)? screen1,
    TResult Function(ValueKey<dynamic> valueKey, WordModel word,
            List<Pair<String, int>> letters)?
        screen2,
    TResult Function(ValueKey<dynamic> valueKey, WordModel word)? screen3,
    TResult Function(ValueKey<dynamic> valueKey, bool cantHear, WordModel word,
            List<WordModel> selectableWords)?
        screen4,
    TResult Function()? finalScreen,
    TResult Function()? zeroHealthScreen,
    TResult Function(WordModel word)? success,
    required TResult orElse(),
  }) {
    if (screen1 != null) {
      return screen1(valueKey, word);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_TrainingInitial value) initial,
    required TResult Function(_TrainingIsLoading value) loading,
    required TResult Function(_TrainingFailed value) failed,
    required TResult Function(_Screen1 value) screen1,
    required TResult Function(_Screen2 value) screen2,
    required TResult Function(_Screen3 value) screen3,
    required TResult Function(_Screen4 value) screen4,
    required TResult Function(_FinalScreen value) finalScreen,
    required TResult Function(_ZeroHealthScreen value) zeroHealthScreen,
    required TResult Function(_Success value) success,
  }) {
    return screen1(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_TrainingInitial value)? initial,
    TResult? Function(_TrainingIsLoading value)? loading,
    TResult? Function(_TrainingFailed value)? failed,
    TResult? Function(_Screen1 value)? screen1,
    TResult? Function(_Screen2 value)? screen2,
    TResult? Function(_Screen3 value)? screen3,
    TResult? Function(_Screen4 value)? screen4,
    TResult? Function(_FinalScreen value)? finalScreen,
    TResult? Function(_ZeroHealthScreen value)? zeroHealthScreen,
    TResult? Function(_Success value)? success,
  }) {
    return screen1?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_TrainingInitial value)? initial,
    TResult Function(_TrainingIsLoading value)? loading,
    TResult Function(_TrainingFailed value)? failed,
    TResult Function(_Screen1 value)? screen1,
    TResult Function(_Screen2 value)? screen2,
    TResult Function(_Screen3 value)? screen3,
    TResult Function(_Screen4 value)? screen4,
    TResult Function(_FinalScreen value)? finalScreen,
    TResult Function(_ZeroHealthScreen value)? zeroHealthScreen,
    TResult Function(_Success value)? success,
    required TResult orElse(),
  }) {
    if (screen1 != null) {
      return screen1(this);
    }
    return orElse();
  }
}

abstract class _Screen1 implements TrainingState {
  const factory _Screen1(
      {required final ValueKey<dynamic> valueKey,
      required final WordModel word}) = _$Screen1Impl;

  ValueKey<dynamic> get valueKey;
  WordModel get word;
  @JsonKey(ignore: true)
  _$$Screen1ImplCopyWith<_$Screen1Impl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Screen2ImplCopyWith<$Res> {
  factory _$$Screen2ImplCopyWith(
          _$Screen2Impl value, $Res Function(_$Screen2Impl) then) =
      __$$Screen2ImplCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {ValueKey<dynamic> valueKey,
      WordModel word,
      List<Pair<String, int>> letters});
}

/// @nodoc
class __$$Screen2ImplCopyWithImpl<$Res>
    extends _$TrainingStateCopyWithImpl<$Res, _$Screen2Impl>
    implements _$$Screen2ImplCopyWith<$Res> {
  __$$Screen2ImplCopyWithImpl(
      _$Screen2Impl _value, $Res Function(_$Screen2Impl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? valueKey = null,
    Object? word = null,
    Object? letters = null,
  }) {
    return _then(_$Screen2Impl(
      valueKey: null == valueKey
          ? _value.valueKey
          : valueKey // ignore: cast_nullable_to_non_nullable
              as ValueKey<dynamic>,
      word: null == word
          ? _value.word
          : word // ignore: cast_nullable_to_non_nullable
              as WordModel,
      letters: null == letters
          ? _value._letters
          : letters // ignore: cast_nullable_to_non_nullable
              as List<Pair<String, int>>,
    ));
  }
}

/// @nodoc

class _$Screen2Impl implements _Screen2 {
  const _$Screen2Impl(
      {required this.valueKey,
      required this.word,
      required final List<Pair<String, int>> letters})
      : _letters = letters;

  @override
  final ValueKey<dynamic> valueKey;
  @override
  final WordModel word;
  final List<Pair<String, int>> _letters;
  @override
  List<Pair<String, int>> get letters {
    if (_letters is EqualUnmodifiableListView) return _letters;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_letters);
  }

  @override
  String toString() {
    return 'TrainingState.screen2(valueKey: $valueKey, word: $word, letters: $letters)';
  }

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Screen2ImplCopyWith<_$Screen2Impl> get copyWith =>
      __$$Screen2ImplCopyWithImpl<_$Screen2Impl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(String message) failed,
    required TResult Function(ValueKey<dynamic> valueKey, WordModel word)
        screen1,
    required TResult Function(ValueKey<dynamic> valueKey, WordModel word,
            List<Pair<String, int>> letters)
        screen2,
    required TResult Function(ValueKey<dynamic> valueKey, WordModel word)
        screen3,
    required TResult Function(ValueKey<dynamic> valueKey, bool cantHear,
            WordModel word, List<WordModel> selectableWords)
        screen4,
    required TResult Function() finalScreen,
    required TResult Function() zeroHealthScreen,
    required TResult Function(WordModel word) success,
  }) {
    return screen2(valueKey, word, letters);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(String message)? failed,
    TResult? Function(ValueKey<dynamic> valueKey, WordModel word)? screen1,
    TResult? Function(ValueKey<dynamic> valueKey, WordModel word,
            List<Pair<String, int>> letters)?
        screen2,
    TResult? Function(ValueKey<dynamic> valueKey, WordModel word)? screen3,
    TResult? Function(ValueKey<dynamic> valueKey, bool cantHear, WordModel word,
            List<WordModel> selectableWords)?
        screen4,
    TResult? Function()? finalScreen,
    TResult? Function()? zeroHealthScreen,
    TResult? Function(WordModel word)? success,
  }) {
    return screen2?.call(valueKey, word, letters);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(String message)? failed,
    TResult Function(ValueKey<dynamic> valueKey, WordModel word)? screen1,
    TResult Function(ValueKey<dynamic> valueKey, WordModel word,
            List<Pair<String, int>> letters)?
        screen2,
    TResult Function(ValueKey<dynamic> valueKey, WordModel word)? screen3,
    TResult Function(ValueKey<dynamic> valueKey, bool cantHear, WordModel word,
            List<WordModel> selectableWords)?
        screen4,
    TResult Function()? finalScreen,
    TResult Function()? zeroHealthScreen,
    TResult Function(WordModel word)? success,
    required TResult orElse(),
  }) {
    if (screen2 != null) {
      return screen2(valueKey, word, letters);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_TrainingInitial value) initial,
    required TResult Function(_TrainingIsLoading value) loading,
    required TResult Function(_TrainingFailed value) failed,
    required TResult Function(_Screen1 value) screen1,
    required TResult Function(_Screen2 value) screen2,
    required TResult Function(_Screen3 value) screen3,
    required TResult Function(_Screen4 value) screen4,
    required TResult Function(_FinalScreen value) finalScreen,
    required TResult Function(_ZeroHealthScreen value) zeroHealthScreen,
    required TResult Function(_Success value) success,
  }) {
    return screen2(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_TrainingInitial value)? initial,
    TResult? Function(_TrainingIsLoading value)? loading,
    TResult? Function(_TrainingFailed value)? failed,
    TResult? Function(_Screen1 value)? screen1,
    TResult? Function(_Screen2 value)? screen2,
    TResult? Function(_Screen3 value)? screen3,
    TResult? Function(_Screen4 value)? screen4,
    TResult? Function(_FinalScreen value)? finalScreen,
    TResult? Function(_ZeroHealthScreen value)? zeroHealthScreen,
    TResult? Function(_Success value)? success,
  }) {
    return screen2?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_TrainingInitial value)? initial,
    TResult Function(_TrainingIsLoading value)? loading,
    TResult Function(_TrainingFailed value)? failed,
    TResult Function(_Screen1 value)? screen1,
    TResult Function(_Screen2 value)? screen2,
    TResult Function(_Screen3 value)? screen3,
    TResult Function(_Screen4 value)? screen4,
    TResult Function(_FinalScreen value)? finalScreen,
    TResult Function(_ZeroHealthScreen value)? zeroHealthScreen,
    TResult Function(_Success value)? success,
    required TResult orElse(),
  }) {
    if (screen2 != null) {
      return screen2(this);
    }
    return orElse();
  }
}

abstract class _Screen2 implements TrainingState {
  const factory _Screen2(
      {required final ValueKey<dynamic> valueKey,
      required final WordModel word,
      required final List<Pair<String, int>> letters}) = _$Screen2Impl;

  ValueKey<dynamic> get valueKey;
  WordModel get word;
  List<Pair<String, int>> get letters;
  @JsonKey(ignore: true)
  _$$Screen2ImplCopyWith<_$Screen2Impl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Screen3ImplCopyWith<$Res> {
  factory _$$Screen3ImplCopyWith(
          _$Screen3Impl value, $Res Function(_$Screen3Impl) then) =
      __$$Screen3ImplCopyWithImpl<$Res>;
  @useResult
  $Res call({ValueKey<dynamic> valueKey, WordModel word});
}

/// @nodoc
class __$$Screen3ImplCopyWithImpl<$Res>
    extends _$TrainingStateCopyWithImpl<$Res, _$Screen3Impl>
    implements _$$Screen3ImplCopyWith<$Res> {
  __$$Screen3ImplCopyWithImpl(
      _$Screen3Impl _value, $Res Function(_$Screen3Impl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? valueKey = null,
    Object? word = null,
  }) {
    return _then(_$Screen3Impl(
      valueKey: null == valueKey
          ? _value.valueKey
          : valueKey // ignore: cast_nullable_to_non_nullable
              as ValueKey<dynamic>,
      word: null == word
          ? _value.word
          : word // ignore: cast_nullable_to_non_nullable
              as WordModel,
    ));
  }
}

/// @nodoc

class _$Screen3Impl implements _Screen3 {
  const _$Screen3Impl({required this.valueKey, required this.word});

  @override
  final ValueKey<dynamic> valueKey;
  @override
  final WordModel word;

  @override
  String toString() {
    return 'TrainingState.screen3(valueKey: $valueKey, word: $word)';
  }

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Screen3ImplCopyWith<_$Screen3Impl> get copyWith =>
      __$$Screen3ImplCopyWithImpl<_$Screen3Impl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(String message) failed,
    required TResult Function(ValueKey<dynamic> valueKey, WordModel word)
        screen1,
    required TResult Function(ValueKey<dynamic> valueKey, WordModel word,
            List<Pair<String, int>> letters)
        screen2,
    required TResult Function(ValueKey<dynamic> valueKey, WordModel word)
        screen3,
    required TResult Function(ValueKey<dynamic> valueKey, bool cantHear,
            WordModel word, List<WordModel> selectableWords)
        screen4,
    required TResult Function() finalScreen,
    required TResult Function() zeroHealthScreen,
    required TResult Function(WordModel word) success,
  }) {
    return screen3(valueKey, word);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(String message)? failed,
    TResult? Function(ValueKey<dynamic> valueKey, WordModel word)? screen1,
    TResult? Function(ValueKey<dynamic> valueKey, WordModel word,
            List<Pair<String, int>> letters)?
        screen2,
    TResult? Function(ValueKey<dynamic> valueKey, WordModel word)? screen3,
    TResult? Function(ValueKey<dynamic> valueKey, bool cantHear, WordModel word,
            List<WordModel> selectableWords)?
        screen4,
    TResult? Function()? finalScreen,
    TResult? Function()? zeroHealthScreen,
    TResult? Function(WordModel word)? success,
  }) {
    return screen3?.call(valueKey, word);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(String message)? failed,
    TResult Function(ValueKey<dynamic> valueKey, WordModel word)? screen1,
    TResult Function(ValueKey<dynamic> valueKey, WordModel word,
            List<Pair<String, int>> letters)?
        screen2,
    TResult Function(ValueKey<dynamic> valueKey, WordModel word)? screen3,
    TResult Function(ValueKey<dynamic> valueKey, bool cantHear, WordModel word,
            List<WordModel> selectableWords)?
        screen4,
    TResult Function()? finalScreen,
    TResult Function()? zeroHealthScreen,
    TResult Function(WordModel word)? success,
    required TResult orElse(),
  }) {
    if (screen3 != null) {
      return screen3(valueKey, word);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_TrainingInitial value) initial,
    required TResult Function(_TrainingIsLoading value) loading,
    required TResult Function(_TrainingFailed value) failed,
    required TResult Function(_Screen1 value) screen1,
    required TResult Function(_Screen2 value) screen2,
    required TResult Function(_Screen3 value) screen3,
    required TResult Function(_Screen4 value) screen4,
    required TResult Function(_FinalScreen value) finalScreen,
    required TResult Function(_ZeroHealthScreen value) zeroHealthScreen,
    required TResult Function(_Success value) success,
  }) {
    return screen3(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_TrainingInitial value)? initial,
    TResult? Function(_TrainingIsLoading value)? loading,
    TResult? Function(_TrainingFailed value)? failed,
    TResult? Function(_Screen1 value)? screen1,
    TResult? Function(_Screen2 value)? screen2,
    TResult? Function(_Screen3 value)? screen3,
    TResult? Function(_Screen4 value)? screen4,
    TResult? Function(_FinalScreen value)? finalScreen,
    TResult? Function(_ZeroHealthScreen value)? zeroHealthScreen,
    TResult? Function(_Success value)? success,
  }) {
    return screen3?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_TrainingInitial value)? initial,
    TResult Function(_TrainingIsLoading value)? loading,
    TResult Function(_TrainingFailed value)? failed,
    TResult Function(_Screen1 value)? screen1,
    TResult Function(_Screen2 value)? screen2,
    TResult Function(_Screen3 value)? screen3,
    TResult Function(_Screen4 value)? screen4,
    TResult Function(_FinalScreen value)? finalScreen,
    TResult Function(_ZeroHealthScreen value)? zeroHealthScreen,
    TResult Function(_Success value)? success,
    required TResult orElse(),
  }) {
    if (screen3 != null) {
      return screen3(this);
    }
    return orElse();
  }
}

abstract class _Screen3 implements TrainingState {
  const factory _Screen3(
      {required final ValueKey<dynamic> valueKey,
      required final WordModel word}) = _$Screen3Impl;

  ValueKey<dynamic> get valueKey;
  WordModel get word;
  @JsonKey(ignore: true)
  _$$Screen3ImplCopyWith<_$Screen3Impl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Screen4ImplCopyWith<$Res> {
  factory _$$Screen4ImplCopyWith(
          _$Screen4Impl value, $Res Function(_$Screen4Impl) then) =
      __$$Screen4ImplCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {ValueKey<dynamic> valueKey,
      bool cantHear,
      WordModel word,
      List<WordModel> selectableWords});
}

/// @nodoc
class __$$Screen4ImplCopyWithImpl<$Res>
    extends _$TrainingStateCopyWithImpl<$Res, _$Screen4Impl>
    implements _$$Screen4ImplCopyWith<$Res> {
  __$$Screen4ImplCopyWithImpl(
      _$Screen4Impl _value, $Res Function(_$Screen4Impl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? valueKey = null,
    Object? cantHear = null,
    Object? word = null,
    Object? selectableWords = null,
  }) {
    return _then(_$Screen4Impl(
      valueKey: null == valueKey
          ? _value.valueKey
          : valueKey // ignore: cast_nullable_to_non_nullable
              as ValueKey<dynamic>,
      cantHear: null == cantHear
          ? _value.cantHear
          : cantHear // ignore: cast_nullable_to_non_nullable
              as bool,
      word: null == word
          ? _value.word
          : word // ignore: cast_nullable_to_non_nullable
              as WordModel,
      selectableWords: null == selectableWords
          ? _value._selectableWords
          : selectableWords // ignore: cast_nullable_to_non_nullable
              as List<WordModel>,
    ));
  }
}

/// @nodoc

class _$Screen4Impl implements _Screen4 {
  const _$Screen4Impl(
      {required this.valueKey,
      required this.cantHear,
      required this.word,
      required final List<WordModel> selectableWords})
      : _selectableWords = selectableWords;

  @override
  final ValueKey<dynamic> valueKey;
  @override
  final bool cantHear;
  @override
  final WordModel word;
  final List<WordModel> _selectableWords;
  @override
  List<WordModel> get selectableWords {
    if (_selectableWords is EqualUnmodifiableListView) return _selectableWords;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_selectableWords);
  }

  @override
  String toString() {
    return 'TrainingState.screen4(valueKey: $valueKey, cantHear: $cantHear, word: $word, selectableWords: $selectableWords)';
  }

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Screen4ImplCopyWith<_$Screen4Impl> get copyWith =>
      __$$Screen4ImplCopyWithImpl<_$Screen4Impl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(String message) failed,
    required TResult Function(ValueKey<dynamic> valueKey, WordModel word)
        screen1,
    required TResult Function(ValueKey<dynamic> valueKey, WordModel word,
            List<Pair<String, int>> letters)
        screen2,
    required TResult Function(ValueKey<dynamic> valueKey, WordModel word)
        screen3,
    required TResult Function(ValueKey<dynamic> valueKey, bool cantHear,
            WordModel word, List<WordModel> selectableWords)
        screen4,
    required TResult Function() finalScreen,
    required TResult Function() zeroHealthScreen,
    required TResult Function(WordModel word) success,
  }) {
    return screen4(valueKey, cantHear, word, selectableWords);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(String message)? failed,
    TResult? Function(ValueKey<dynamic> valueKey, WordModel word)? screen1,
    TResult? Function(ValueKey<dynamic> valueKey, WordModel word,
            List<Pair<String, int>> letters)?
        screen2,
    TResult? Function(ValueKey<dynamic> valueKey, WordModel word)? screen3,
    TResult? Function(ValueKey<dynamic> valueKey, bool cantHear, WordModel word,
            List<WordModel> selectableWords)?
        screen4,
    TResult? Function()? finalScreen,
    TResult? Function()? zeroHealthScreen,
    TResult? Function(WordModel word)? success,
  }) {
    return screen4?.call(valueKey, cantHear, word, selectableWords);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(String message)? failed,
    TResult Function(ValueKey<dynamic> valueKey, WordModel word)? screen1,
    TResult Function(ValueKey<dynamic> valueKey, WordModel word,
            List<Pair<String, int>> letters)?
        screen2,
    TResult Function(ValueKey<dynamic> valueKey, WordModel word)? screen3,
    TResult Function(ValueKey<dynamic> valueKey, bool cantHear, WordModel word,
            List<WordModel> selectableWords)?
        screen4,
    TResult Function()? finalScreen,
    TResult Function()? zeroHealthScreen,
    TResult Function(WordModel word)? success,
    required TResult orElse(),
  }) {
    if (screen4 != null) {
      return screen4(valueKey, cantHear, word, selectableWords);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_TrainingInitial value) initial,
    required TResult Function(_TrainingIsLoading value) loading,
    required TResult Function(_TrainingFailed value) failed,
    required TResult Function(_Screen1 value) screen1,
    required TResult Function(_Screen2 value) screen2,
    required TResult Function(_Screen3 value) screen3,
    required TResult Function(_Screen4 value) screen4,
    required TResult Function(_FinalScreen value) finalScreen,
    required TResult Function(_ZeroHealthScreen value) zeroHealthScreen,
    required TResult Function(_Success value) success,
  }) {
    return screen4(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_TrainingInitial value)? initial,
    TResult? Function(_TrainingIsLoading value)? loading,
    TResult? Function(_TrainingFailed value)? failed,
    TResult? Function(_Screen1 value)? screen1,
    TResult? Function(_Screen2 value)? screen2,
    TResult? Function(_Screen3 value)? screen3,
    TResult? Function(_Screen4 value)? screen4,
    TResult? Function(_FinalScreen value)? finalScreen,
    TResult? Function(_ZeroHealthScreen value)? zeroHealthScreen,
    TResult? Function(_Success value)? success,
  }) {
    return screen4?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_TrainingInitial value)? initial,
    TResult Function(_TrainingIsLoading value)? loading,
    TResult Function(_TrainingFailed value)? failed,
    TResult Function(_Screen1 value)? screen1,
    TResult Function(_Screen2 value)? screen2,
    TResult Function(_Screen3 value)? screen3,
    TResult Function(_Screen4 value)? screen4,
    TResult Function(_FinalScreen value)? finalScreen,
    TResult Function(_ZeroHealthScreen value)? zeroHealthScreen,
    TResult Function(_Success value)? success,
    required TResult orElse(),
  }) {
    if (screen4 != null) {
      return screen4(this);
    }
    return orElse();
  }
}

abstract class _Screen4 implements TrainingState {
  const factory _Screen4(
      {required final ValueKey<dynamic> valueKey,
      required final bool cantHear,
      required final WordModel word,
      required final List<WordModel> selectableWords}) = _$Screen4Impl;

  ValueKey<dynamic> get valueKey;
  bool get cantHear;
  WordModel get word;
  List<WordModel> get selectableWords;
  @JsonKey(ignore: true)
  _$$Screen4ImplCopyWith<_$Screen4Impl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FinalScreenImplCopyWith<$Res> {
  factory _$$FinalScreenImplCopyWith(
          _$FinalScreenImpl value, $Res Function(_$FinalScreenImpl) then) =
      __$$FinalScreenImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$FinalScreenImplCopyWithImpl<$Res>
    extends _$TrainingStateCopyWithImpl<$Res, _$FinalScreenImpl>
    implements _$$FinalScreenImplCopyWith<$Res> {
  __$$FinalScreenImplCopyWithImpl(
      _$FinalScreenImpl _value, $Res Function(_$FinalScreenImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$FinalScreenImpl implements _FinalScreen {
  const _$FinalScreenImpl();

  @override
  String toString() {
    return 'TrainingState.finalScreen()';
  }

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(String message) failed,
    required TResult Function(ValueKey<dynamic> valueKey, WordModel word)
        screen1,
    required TResult Function(ValueKey<dynamic> valueKey, WordModel word,
            List<Pair<String, int>> letters)
        screen2,
    required TResult Function(ValueKey<dynamic> valueKey, WordModel word)
        screen3,
    required TResult Function(ValueKey<dynamic> valueKey, bool cantHear,
            WordModel word, List<WordModel> selectableWords)
        screen4,
    required TResult Function() finalScreen,
    required TResult Function() zeroHealthScreen,
    required TResult Function(WordModel word) success,
  }) {
    return finalScreen();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(String message)? failed,
    TResult? Function(ValueKey<dynamic> valueKey, WordModel word)? screen1,
    TResult? Function(ValueKey<dynamic> valueKey, WordModel word,
            List<Pair<String, int>> letters)?
        screen2,
    TResult? Function(ValueKey<dynamic> valueKey, WordModel word)? screen3,
    TResult? Function(ValueKey<dynamic> valueKey, bool cantHear, WordModel word,
            List<WordModel> selectableWords)?
        screen4,
    TResult? Function()? finalScreen,
    TResult? Function()? zeroHealthScreen,
    TResult? Function(WordModel word)? success,
  }) {
    return finalScreen?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(String message)? failed,
    TResult Function(ValueKey<dynamic> valueKey, WordModel word)? screen1,
    TResult Function(ValueKey<dynamic> valueKey, WordModel word,
            List<Pair<String, int>> letters)?
        screen2,
    TResult Function(ValueKey<dynamic> valueKey, WordModel word)? screen3,
    TResult Function(ValueKey<dynamic> valueKey, bool cantHear, WordModel word,
            List<WordModel> selectableWords)?
        screen4,
    TResult Function()? finalScreen,
    TResult Function()? zeroHealthScreen,
    TResult Function(WordModel word)? success,
    required TResult orElse(),
  }) {
    if (finalScreen != null) {
      return finalScreen();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_TrainingInitial value) initial,
    required TResult Function(_TrainingIsLoading value) loading,
    required TResult Function(_TrainingFailed value) failed,
    required TResult Function(_Screen1 value) screen1,
    required TResult Function(_Screen2 value) screen2,
    required TResult Function(_Screen3 value) screen3,
    required TResult Function(_Screen4 value) screen4,
    required TResult Function(_FinalScreen value) finalScreen,
    required TResult Function(_ZeroHealthScreen value) zeroHealthScreen,
    required TResult Function(_Success value) success,
  }) {
    return finalScreen(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_TrainingInitial value)? initial,
    TResult? Function(_TrainingIsLoading value)? loading,
    TResult? Function(_TrainingFailed value)? failed,
    TResult? Function(_Screen1 value)? screen1,
    TResult? Function(_Screen2 value)? screen2,
    TResult? Function(_Screen3 value)? screen3,
    TResult? Function(_Screen4 value)? screen4,
    TResult? Function(_FinalScreen value)? finalScreen,
    TResult? Function(_ZeroHealthScreen value)? zeroHealthScreen,
    TResult? Function(_Success value)? success,
  }) {
    return finalScreen?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_TrainingInitial value)? initial,
    TResult Function(_TrainingIsLoading value)? loading,
    TResult Function(_TrainingFailed value)? failed,
    TResult Function(_Screen1 value)? screen1,
    TResult Function(_Screen2 value)? screen2,
    TResult Function(_Screen3 value)? screen3,
    TResult Function(_Screen4 value)? screen4,
    TResult Function(_FinalScreen value)? finalScreen,
    TResult Function(_ZeroHealthScreen value)? zeroHealthScreen,
    TResult Function(_Success value)? success,
    required TResult orElse(),
  }) {
    if (finalScreen != null) {
      return finalScreen(this);
    }
    return orElse();
  }
}

abstract class _FinalScreen implements TrainingState {
  const factory _FinalScreen() = _$FinalScreenImpl;
}

/// @nodoc
abstract class _$$ZeroHealthScreenImplCopyWith<$Res> {
  factory _$$ZeroHealthScreenImplCopyWith(_$ZeroHealthScreenImpl value,
          $Res Function(_$ZeroHealthScreenImpl) then) =
      __$$ZeroHealthScreenImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ZeroHealthScreenImplCopyWithImpl<$Res>
    extends _$TrainingStateCopyWithImpl<$Res, _$ZeroHealthScreenImpl>
    implements _$$ZeroHealthScreenImplCopyWith<$Res> {
  __$$ZeroHealthScreenImplCopyWithImpl(_$ZeroHealthScreenImpl _value,
      $Res Function(_$ZeroHealthScreenImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ZeroHealthScreenImpl implements _ZeroHealthScreen {
  const _$ZeroHealthScreenImpl();

  @override
  String toString() {
    return 'TrainingState.zeroHealthScreen()';
  }

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(String message) failed,
    required TResult Function(ValueKey<dynamic> valueKey, WordModel word)
        screen1,
    required TResult Function(ValueKey<dynamic> valueKey, WordModel word,
            List<Pair<String, int>> letters)
        screen2,
    required TResult Function(ValueKey<dynamic> valueKey, WordModel word)
        screen3,
    required TResult Function(ValueKey<dynamic> valueKey, bool cantHear,
            WordModel word, List<WordModel> selectableWords)
        screen4,
    required TResult Function() finalScreen,
    required TResult Function() zeroHealthScreen,
    required TResult Function(WordModel word) success,
  }) {
    return zeroHealthScreen();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(String message)? failed,
    TResult? Function(ValueKey<dynamic> valueKey, WordModel word)? screen1,
    TResult? Function(ValueKey<dynamic> valueKey, WordModel word,
            List<Pair<String, int>> letters)?
        screen2,
    TResult? Function(ValueKey<dynamic> valueKey, WordModel word)? screen3,
    TResult? Function(ValueKey<dynamic> valueKey, bool cantHear, WordModel word,
            List<WordModel> selectableWords)?
        screen4,
    TResult? Function()? finalScreen,
    TResult? Function()? zeroHealthScreen,
    TResult? Function(WordModel word)? success,
  }) {
    return zeroHealthScreen?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(String message)? failed,
    TResult Function(ValueKey<dynamic> valueKey, WordModel word)? screen1,
    TResult Function(ValueKey<dynamic> valueKey, WordModel word,
            List<Pair<String, int>> letters)?
        screen2,
    TResult Function(ValueKey<dynamic> valueKey, WordModel word)? screen3,
    TResult Function(ValueKey<dynamic> valueKey, bool cantHear, WordModel word,
            List<WordModel> selectableWords)?
        screen4,
    TResult Function()? finalScreen,
    TResult Function()? zeroHealthScreen,
    TResult Function(WordModel word)? success,
    required TResult orElse(),
  }) {
    if (zeroHealthScreen != null) {
      return zeroHealthScreen();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_TrainingInitial value) initial,
    required TResult Function(_TrainingIsLoading value) loading,
    required TResult Function(_TrainingFailed value) failed,
    required TResult Function(_Screen1 value) screen1,
    required TResult Function(_Screen2 value) screen2,
    required TResult Function(_Screen3 value) screen3,
    required TResult Function(_Screen4 value) screen4,
    required TResult Function(_FinalScreen value) finalScreen,
    required TResult Function(_ZeroHealthScreen value) zeroHealthScreen,
    required TResult Function(_Success value) success,
  }) {
    return zeroHealthScreen(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_TrainingInitial value)? initial,
    TResult? Function(_TrainingIsLoading value)? loading,
    TResult? Function(_TrainingFailed value)? failed,
    TResult? Function(_Screen1 value)? screen1,
    TResult? Function(_Screen2 value)? screen2,
    TResult? Function(_Screen3 value)? screen3,
    TResult? Function(_Screen4 value)? screen4,
    TResult? Function(_FinalScreen value)? finalScreen,
    TResult? Function(_ZeroHealthScreen value)? zeroHealthScreen,
    TResult? Function(_Success value)? success,
  }) {
    return zeroHealthScreen?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_TrainingInitial value)? initial,
    TResult Function(_TrainingIsLoading value)? loading,
    TResult Function(_TrainingFailed value)? failed,
    TResult Function(_Screen1 value)? screen1,
    TResult Function(_Screen2 value)? screen2,
    TResult Function(_Screen3 value)? screen3,
    TResult Function(_Screen4 value)? screen4,
    TResult Function(_FinalScreen value)? finalScreen,
    TResult Function(_ZeroHealthScreen value)? zeroHealthScreen,
    TResult Function(_Success value)? success,
    required TResult orElse(),
  }) {
    if (zeroHealthScreen != null) {
      return zeroHealthScreen(this);
    }
    return orElse();
  }
}

abstract class _ZeroHealthScreen implements TrainingState {
  const factory _ZeroHealthScreen() = _$ZeroHealthScreenImpl;
}

/// @nodoc
abstract class _$$SuccessImplCopyWith<$Res> {
  factory _$$SuccessImplCopyWith(
          _$SuccessImpl value, $Res Function(_$SuccessImpl) then) =
      __$$SuccessImplCopyWithImpl<$Res>;
  @useResult
  $Res call({WordModel word});
}

/// @nodoc
class __$$SuccessImplCopyWithImpl<$Res>
    extends _$TrainingStateCopyWithImpl<$Res, _$SuccessImpl>
    implements _$$SuccessImplCopyWith<$Res> {
  __$$SuccessImplCopyWithImpl(
      _$SuccessImpl _value, $Res Function(_$SuccessImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? word = null,
  }) {
    return _then(_$SuccessImpl(
      word: null == word
          ? _value.word
          : word // ignore: cast_nullable_to_non_nullable
              as WordModel,
    ));
  }
}

/// @nodoc

class _$SuccessImpl implements _Success {
  const _$SuccessImpl({required this.word});

  @override
  final WordModel word;

  @override
  String toString() {
    return 'TrainingState.success(word: $word)';
  }

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SuccessImplCopyWith<_$SuccessImpl> get copyWith =>
      __$$SuccessImplCopyWithImpl<_$SuccessImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(String message) failed,
    required TResult Function(ValueKey<dynamic> valueKey, WordModel word)
        screen1,
    required TResult Function(ValueKey<dynamic> valueKey, WordModel word,
            List<Pair<String, int>> letters)
        screen2,
    required TResult Function(ValueKey<dynamic> valueKey, WordModel word)
        screen3,
    required TResult Function(ValueKey<dynamic> valueKey, bool cantHear,
            WordModel word, List<WordModel> selectableWords)
        screen4,
    required TResult Function() finalScreen,
    required TResult Function() zeroHealthScreen,
    required TResult Function(WordModel word) success,
  }) {
    return success(word);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(String message)? failed,
    TResult? Function(ValueKey<dynamic> valueKey, WordModel word)? screen1,
    TResult? Function(ValueKey<dynamic> valueKey, WordModel word,
            List<Pair<String, int>> letters)?
        screen2,
    TResult? Function(ValueKey<dynamic> valueKey, WordModel word)? screen3,
    TResult? Function(ValueKey<dynamic> valueKey, bool cantHear, WordModel word,
            List<WordModel> selectableWords)?
        screen4,
    TResult? Function()? finalScreen,
    TResult? Function()? zeroHealthScreen,
    TResult? Function(WordModel word)? success,
  }) {
    return success?.call(word);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(String message)? failed,
    TResult Function(ValueKey<dynamic> valueKey, WordModel word)? screen1,
    TResult Function(ValueKey<dynamic> valueKey, WordModel word,
            List<Pair<String, int>> letters)?
        screen2,
    TResult Function(ValueKey<dynamic> valueKey, WordModel word)? screen3,
    TResult Function(ValueKey<dynamic> valueKey, bool cantHear, WordModel word,
            List<WordModel> selectableWords)?
        screen4,
    TResult Function()? finalScreen,
    TResult Function()? zeroHealthScreen,
    TResult Function(WordModel word)? success,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(word);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_TrainingInitial value) initial,
    required TResult Function(_TrainingIsLoading value) loading,
    required TResult Function(_TrainingFailed value) failed,
    required TResult Function(_Screen1 value) screen1,
    required TResult Function(_Screen2 value) screen2,
    required TResult Function(_Screen3 value) screen3,
    required TResult Function(_Screen4 value) screen4,
    required TResult Function(_FinalScreen value) finalScreen,
    required TResult Function(_ZeroHealthScreen value) zeroHealthScreen,
    required TResult Function(_Success value) success,
  }) {
    return success(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_TrainingInitial value)? initial,
    TResult? Function(_TrainingIsLoading value)? loading,
    TResult? Function(_TrainingFailed value)? failed,
    TResult? Function(_Screen1 value)? screen1,
    TResult? Function(_Screen2 value)? screen2,
    TResult? Function(_Screen3 value)? screen3,
    TResult? Function(_Screen4 value)? screen4,
    TResult? Function(_FinalScreen value)? finalScreen,
    TResult? Function(_ZeroHealthScreen value)? zeroHealthScreen,
    TResult? Function(_Success value)? success,
  }) {
    return success?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_TrainingInitial value)? initial,
    TResult Function(_TrainingIsLoading value)? loading,
    TResult Function(_TrainingFailed value)? failed,
    TResult Function(_Screen1 value)? screen1,
    TResult Function(_Screen2 value)? screen2,
    TResult Function(_Screen3 value)? screen3,
    TResult Function(_Screen4 value)? screen4,
    TResult Function(_FinalScreen value)? finalScreen,
    TResult Function(_ZeroHealthScreen value)? zeroHealthScreen,
    TResult Function(_Success value)? success,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(this);
    }
    return orElse();
  }
}

abstract class _Success implements TrainingState {
  const factory _Success({required final WordModel word}) = _$SuccessImpl;

  WordModel get word;
  @JsonKey(ignore: true)
  _$$SuccessImplCopyWith<_$SuccessImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$TrainingEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Topic topic) setTopic,
    required TResult Function(Subtopic subtopic) setSubtopic,
    required TResult Function() nextStep,
    required TResult Function() goSuccessfulScreen,
    required TResult Function() cantHear,
    required TResult Function() cantSpeak,
    required TResult Function() zeroHealth,
    required TResult Function(Subtopic subtopic) startStudy,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Topic topic)? setTopic,
    TResult? Function(Subtopic subtopic)? setSubtopic,
    TResult? Function()? nextStep,
    TResult? Function()? goSuccessfulScreen,
    TResult? Function()? cantHear,
    TResult? Function()? cantSpeak,
    TResult? Function()? zeroHealth,
    TResult? Function(Subtopic subtopic)? startStudy,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Topic topic)? setTopic,
    TResult Function(Subtopic subtopic)? setSubtopic,
    TResult Function()? nextStep,
    TResult Function()? goSuccessfulScreen,
    TResult Function()? cantHear,
    TResult Function()? cantSpeak,
    TResult Function()? zeroHealth,
    TResult Function(Subtopic subtopic)? startStudy,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SetTopic value) setTopic,
    required TResult Function(_SetSubtopic value) setSubtopic,
    required TResult Function(_NextStep value) nextStep,
    required TResult Function(_GoSuccessfulScreen value) goSuccessfulScreen,
    required TResult Function(_CantHear value) cantHear,
    required TResult Function(_CantSpeak value) cantSpeak,
    required TResult Function(_ZeroHealth value) zeroHealth,
    required TResult Function(_StartStudy value) startStudy,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SetTopic value)? setTopic,
    TResult? Function(_SetSubtopic value)? setSubtopic,
    TResult? Function(_NextStep value)? nextStep,
    TResult? Function(_GoSuccessfulScreen value)? goSuccessfulScreen,
    TResult? Function(_CantHear value)? cantHear,
    TResult? Function(_CantSpeak value)? cantSpeak,
    TResult? Function(_ZeroHealth value)? zeroHealth,
    TResult? Function(_StartStudy value)? startStudy,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SetTopic value)? setTopic,
    TResult Function(_SetSubtopic value)? setSubtopic,
    TResult Function(_NextStep value)? nextStep,
    TResult Function(_GoSuccessfulScreen value)? goSuccessfulScreen,
    TResult Function(_CantHear value)? cantHear,
    TResult Function(_CantSpeak value)? cantSpeak,
    TResult Function(_ZeroHealth value)? zeroHealth,
    TResult Function(_StartStudy value)? startStudy,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TrainingEventCopyWith<$Res> {
  factory $TrainingEventCopyWith(
          TrainingEvent value, $Res Function(TrainingEvent) then) =
      _$TrainingEventCopyWithImpl<$Res, TrainingEvent>;
}

/// @nodoc
class _$TrainingEventCopyWithImpl<$Res, $Val extends TrainingEvent>
    implements $TrainingEventCopyWith<$Res> {
  _$TrainingEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$SetTopicImplCopyWith<$Res> {
  factory _$$SetTopicImplCopyWith(
          _$SetTopicImpl value, $Res Function(_$SetTopicImpl) then) =
      __$$SetTopicImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Topic topic});
}

/// @nodoc
class __$$SetTopicImplCopyWithImpl<$Res>
    extends _$TrainingEventCopyWithImpl<$Res, _$SetTopicImpl>
    implements _$$SetTopicImplCopyWith<$Res> {
  __$$SetTopicImplCopyWithImpl(
      _$SetTopicImpl _value, $Res Function(_$SetTopicImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? topic = null,
  }) {
    return _then(_$SetTopicImpl(
      null == topic
          ? _value.topic
          : topic // ignore: cast_nullable_to_non_nullable
              as Topic,
    ));
  }
}

/// @nodoc

class _$SetTopicImpl implements _SetTopic {
  const _$SetTopicImpl(this.topic);

  @override
  final Topic topic;

  @override
  String toString() {
    return 'TrainingEvent.setTopic(topic: $topic)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SetTopicImpl &&
            (identical(other.topic, topic) || other.topic == topic));
  }

  @override
  int get hashCode => Object.hash(runtimeType, topic);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SetTopicImplCopyWith<_$SetTopicImpl> get copyWith =>
      __$$SetTopicImplCopyWithImpl<_$SetTopicImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Topic topic) setTopic,
    required TResult Function(Subtopic subtopic) setSubtopic,
    required TResult Function() nextStep,
    required TResult Function() goSuccessfulScreen,
    required TResult Function() cantHear,
    required TResult Function() cantSpeak,
    required TResult Function() zeroHealth,
    required TResult Function(Subtopic subtopic) startStudy,
  }) {
    return setTopic(topic);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Topic topic)? setTopic,
    TResult? Function(Subtopic subtopic)? setSubtopic,
    TResult? Function()? nextStep,
    TResult? Function()? goSuccessfulScreen,
    TResult? Function()? cantHear,
    TResult? Function()? cantSpeak,
    TResult? Function()? zeroHealth,
    TResult? Function(Subtopic subtopic)? startStudy,
  }) {
    return setTopic?.call(topic);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Topic topic)? setTopic,
    TResult Function(Subtopic subtopic)? setSubtopic,
    TResult Function()? nextStep,
    TResult Function()? goSuccessfulScreen,
    TResult Function()? cantHear,
    TResult Function()? cantSpeak,
    TResult Function()? zeroHealth,
    TResult Function(Subtopic subtopic)? startStudy,
    required TResult orElse(),
  }) {
    if (setTopic != null) {
      return setTopic(topic);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SetTopic value) setTopic,
    required TResult Function(_SetSubtopic value) setSubtopic,
    required TResult Function(_NextStep value) nextStep,
    required TResult Function(_GoSuccessfulScreen value) goSuccessfulScreen,
    required TResult Function(_CantHear value) cantHear,
    required TResult Function(_CantSpeak value) cantSpeak,
    required TResult Function(_ZeroHealth value) zeroHealth,
    required TResult Function(_StartStudy value) startStudy,
  }) {
    return setTopic(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SetTopic value)? setTopic,
    TResult? Function(_SetSubtopic value)? setSubtopic,
    TResult? Function(_NextStep value)? nextStep,
    TResult? Function(_GoSuccessfulScreen value)? goSuccessfulScreen,
    TResult? Function(_CantHear value)? cantHear,
    TResult? Function(_CantSpeak value)? cantSpeak,
    TResult? Function(_ZeroHealth value)? zeroHealth,
    TResult? Function(_StartStudy value)? startStudy,
  }) {
    return setTopic?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SetTopic value)? setTopic,
    TResult Function(_SetSubtopic value)? setSubtopic,
    TResult Function(_NextStep value)? nextStep,
    TResult Function(_GoSuccessfulScreen value)? goSuccessfulScreen,
    TResult Function(_CantHear value)? cantHear,
    TResult Function(_CantSpeak value)? cantSpeak,
    TResult Function(_ZeroHealth value)? zeroHealth,
    TResult Function(_StartStudy value)? startStudy,
    required TResult orElse(),
  }) {
    if (setTopic != null) {
      return setTopic(this);
    }
    return orElse();
  }
}

abstract class _SetTopic implements TrainingEvent {
  const factory _SetTopic(final Topic topic) = _$SetTopicImpl;

  Topic get topic;
  @JsonKey(ignore: true)
  _$$SetTopicImplCopyWith<_$SetTopicImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SetSubtopicImplCopyWith<$Res> {
  factory _$$SetSubtopicImplCopyWith(
          _$SetSubtopicImpl value, $Res Function(_$SetSubtopicImpl) then) =
      __$$SetSubtopicImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Subtopic subtopic});
}

/// @nodoc
class __$$SetSubtopicImplCopyWithImpl<$Res>
    extends _$TrainingEventCopyWithImpl<$Res, _$SetSubtopicImpl>
    implements _$$SetSubtopicImplCopyWith<$Res> {
  __$$SetSubtopicImplCopyWithImpl(
      _$SetSubtopicImpl _value, $Res Function(_$SetSubtopicImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? subtopic = null,
  }) {
    return _then(_$SetSubtopicImpl(
      null == subtopic
          ? _value.subtopic
          : subtopic // ignore: cast_nullable_to_non_nullable
              as Subtopic,
    ));
  }
}

/// @nodoc

class _$SetSubtopicImpl implements _SetSubtopic {
  const _$SetSubtopicImpl(this.subtopic);

  @override
  final Subtopic subtopic;

  @override
  String toString() {
    return 'TrainingEvent.setSubtopic(subtopic: $subtopic)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SetSubtopicImpl &&
            (identical(other.subtopic, subtopic) ||
                other.subtopic == subtopic));
  }

  @override
  int get hashCode => Object.hash(runtimeType, subtopic);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SetSubtopicImplCopyWith<_$SetSubtopicImpl> get copyWith =>
      __$$SetSubtopicImplCopyWithImpl<_$SetSubtopicImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Topic topic) setTopic,
    required TResult Function(Subtopic subtopic) setSubtopic,
    required TResult Function() nextStep,
    required TResult Function() goSuccessfulScreen,
    required TResult Function() cantHear,
    required TResult Function() cantSpeak,
    required TResult Function() zeroHealth,
    required TResult Function(Subtopic subtopic) startStudy,
  }) {
    return setSubtopic(subtopic);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Topic topic)? setTopic,
    TResult? Function(Subtopic subtopic)? setSubtopic,
    TResult? Function()? nextStep,
    TResult? Function()? goSuccessfulScreen,
    TResult? Function()? cantHear,
    TResult? Function()? cantSpeak,
    TResult? Function()? zeroHealth,
    TResult? Function(Subtopic subtopic)? startStudy,
  }) {
    return setSubtopic?.call(subtopic);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Topic topic)? setTopic,
    TResult Function(Subtopic subtopic)? setSubtopic,
    TResult Function()? nextStep,
    TResult Function()? goSuccessfulScreen,
    TResult Function()? cantHear,
    TResult Function()? cantSpeak,
    TResult Function()? zeroHealth,
    TResult Function(Subtopic subtopic)? startStudy,
    required TResult orElse(),
  }) {
    if (setSubtopic != null) {
      return setSubtopic(subtopic);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SetTopic value) setTopic,
    required TResult Function(_SetSubtopic value) setSubtopic,
    required TResult Function(_NextStep value) nextStep,
    required TResult Function(_GoSuccessfulScreen value) goSuccessfulScreen,
    required TResult Function(_CantHear value) cantHear,
    required TResult Function(_CantSpeak value) cantSpeak,
    required TResult Function(_ZeroHealth value) zeroHealth,
    required TResult Function(_StartStudy value) startStudy,
  }) {
    return setSubtopic(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SetTopic value)? setTopic,
    TResult? Function(_SetSubtopic value)? setSubtopic,
    TResult? Function(_NextStep value)? nextStep,
    TResult? Function(_GoSuccessfulScreen value)? goSuccessfulScreen,
    TResult? Function(_CantHear value)? cantHear,
    TResult? Function(_CantSpeak value)? cantSpeak,
    TResult? Function(_ZeroHealth value)? zeroHealth,
    TResult? Function(_StartStudy value)? startStudy,
  }) {
    return setSubtopic?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SetTopic value)? setTopic,
    TResult Function(_SetSubtopic value)? setSubtopic,
    TResult Function(_NextStep value)? nextStep,
    TResult Function(_GoSuccessfulScreen value)? goSuccessfulScreen,
    TResult Function(_CantHear value)? cantHear,
    TResult Function(_CantSpeak value)? cantSpeak,
    TResult Function(_ZeroHealth value)? zeroHealth,
    TResult Function(_StartStudy value)? startStudy,
    required TResult orElse(),
  }) {
    if (setSubtopic != null) {
      return setSubtopic(this);
    }
    return orElse();
  }
}

abstract class _SetSubtopic implements TrainingEvent {
  const factory _SetSubtopic(final Subtopic subtopic) = _$SetSubtopicImpl;

  Subtopic get subtopic;
  @JsonKey(ignore: true)
  _$$SetSubtopicImplCopyWith<_$SetSubtopicImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$NextStepImplCopyWith<$Res> {
  factory _$$NextStepImplCopyWith(
          _$NextStepImpl value, $Res Function(_$NextStepImpl) then) =
      __$$NextStepImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$NextStepImplCopyWithImpl<$Res>
    extends _$TrainingEventCopyWithImpl<$Res, _$NextStepImpl>
    implements _$$NextStepImplCopyWith<$Res> {
  __$$NextStepImplCopyWithImpl(
      _$NextStepImpl _value, $Res Function(_$NextStepImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$NextStepImpl implements _NextStep {
  const _$NextStepImpl();

  @override
  String toString() {
    return 'TrainingEvent.nextStep()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$NextStepImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Topic topic) setTopic,
    required TResult Function(Subtopic subtopic) setSubtopic,
    required TResult Function() nextStep,
    required TResult Function() goSuccessfulScreen,
    required TResult Function() cantHear,
    required TResult Function() cantSpeak,
    required TResult Function() zeroHealth,
    required TResult Function(Subtopic subtopic) startStudy,
  }) {
    return nextStep();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Topic topic)? setTopic,
    TResult? Function(Subtopic subtopic)? setSubtopic,
    TResult? Function()? nextStep,
    TResult? Function()? goSuccessfulScreen,
    TResult? Function()? cantHear,
    TResult? Function()? cantSpeak,
    TResult? Function()? zeroHealth,
    TResult? Function(Subtopic subtopic)? startStudy,
  }) {
    return nextStep?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Topic topic)? setTopic,
    TResult Function(Subtopic subtopic)? setSubtopic,
    TResult Function()? nextStep,
    TResult Function()? goSuccessfulScreen,
    TResult Function()? cantHear,
    TResult Function()? cantSpeak,
    TResult Function()? zeroHealth,
    TResult Function(Subtopic subtopic)? startStudy,
    required TResult orElse(),
  }) {
    if (nextStep != null) {
      return nextStep();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SetTopic value) setTopic,
    required TResult Function(_SetSubtopic value) setSubtopic,
    required TResult Function(_NextStep value) nextStep,
    required TResult Function(_GoSuccessfulScreen value) goSuccessfulScreen,
    required TResult Function(_CantHear value) cantHear,
    required TResult Function(_CantSpeak value) cantSpeak,
    required TResult Function(_ZeroHealth value) zeroHealth,
    required TResult Function(_StartStudy value) startStudy,
  }) {
    return nextStep(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SetTopic value)? setTopic,
    TResult? Function(_SetSubtopic value)? setSubtopic,
    TResult? Function(_NextStep value)? nextStep,
    TResult? Function(_GoSuccessfulScreen value)? goSuccessfulScreen,
    TResult? Function(_CantHear value)? cantHear,
    TResult? Function(_CantSpeak value)? cantSpeak,
    TResult? Function(_ZeroHealth value)? zeroHealth,
    TResult? Function(_StartStudy value)? startStudy,
  }) {
    return nextStep?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SetTopic value)? setTopic,
    TResult Function(_SetSubtopic value)? setSubtopic,
    TResult Function(_NextStep value)? nextStep,
    TResult Function(_GoSuccessfulScreen value)? goSuccessfulScreen,
    TResult Function(_CantHear value)? cantHear,
    TResult Function(_CantSpeak value)? cantSpeak,
    TResult Function(_ZeroHealth value)? zeroHealth,
    TResult Function(_StartStudy value)? startStudy,
    required TResult orElse(),
  }) {
    if (nextStep != null) {
      return nextStep(this);
    }
    return orElse();
  }
}

abstract class _NextStep implements TrainingEvent {
  const factory _NextStep() = _$NextStepImpl;
}

/// @nodoc
abstract class _$$GoSuccessfulScreenImplCopyWith<$Res> {
  factory _$$GoSuccessfulScreenImplCopyWith(_$GoSuccessfulScreenImpl value,
          $Res Function(_$GoSuccessfulScreenImpl) then) =
      __$$GoSuccessfulScreenImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$GoSuccessfulScreenImplCopyWithImpl<$Res>
    extends _$TrainingEventCopyWithImpl<$Res, _$GoSuccessfulScreenImpl>
    implements _$$GoSuccessfulScreenImplCopyWith<$Res> {
  __$$GoSuccessfulScreenImplCopyWithImpl(_$GoSuccessfulScreenImpl _value,
      $Res Function(_$GoSuccessfulScreenImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$GoSuccessfulScreenImpl implements _GoSuccessfulScreen {
  const _$GoSuccessfulScreenImpl();

  @override
  String toString() {
    return 'TrainingEvent.goSuccessfulScreen()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$GoSuccessfulScreenImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Topic topic) setTopic,
    required TResult Function(Subtopic subtopic) setSubtopic,
    required TResult Function() nextStep,
    required TResult Function() goSuccessfulScreen,
    required TResult Function() cantHear,
    required TResult Function() cantSpeak,
    required TResult Function() zeroHealth,
    required TResult Function(Subtopic subtopic) startStudy,
  }) {
    return goSuccessfulScreen();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Topic topic)? setTopic,
    TResult? Function(Subtopic subtopic)? setSubtopic,
    TResult? Function()? nextStep,
    TResult? Function()? goSuccessfulScreen,
    TResult? Function()? cantHear,
    TResult? Function()? cantSpeak,
    TResult? Function()? zeroHealth,
    TResult? Function(Subtopic subtopic)? startStudy,
  }) {
    return goSuccessfulScreen?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Topic topic)? setTopic,
    TResult Function(Subtopic subtopic)? setSubtopic,
    TResult Function()? nextStep,
    TResult Function()? goSuccessfulScreen,
    TResult Function()? cantHear,
    TResult Function()? cantSpeak,
    TResult Function()? zeroHealth,
    TResult Function(Subtopic subtopic)? startStudy,
    required TResult orElse(),
  }) {
    if (goSuccessfulScreen != null) {
      return goSuccessfulScreen();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SetTopic value) setTopic,
    required TResult Function(_SetSubtopic value) setSubtopic,
    required TResult Function(_NextStep value) nextStep,
    required TResult Function(_GoSuccessfulScreen value) goSuccessfulScreen,
    required TResult Function(_CantHear value) cantHear,
    required TResult Function(_CantSpeak value) cantSpeak,
    required TResult Function(_ZeroHealth value) zeroHealth,
    required TResult Function(_StartStudy value) startStudy,
  }) {
    return goSuccessfulScreen(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SetTopic value)? setTopic,
    TResult? Function(_SetSubtopic value)? setSubtopic,
    TResult? Function(_NextStep value)? nextStep,
    TResult? Function(_GoSuccessfulScreen value)? goSuccessfulScreen,
    TResult? Function(_CantHear value)? cantHear,
    TResult? Function(_CantSpeak value)? cantSpeak,
    TResult? Function(_ZeroHealth value)? zeroHealth,
    TResult? Function(_StartStudy value)? startStudy,
  }) {
    return goSuccessfulScreen?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SetTopic value)? setTopic,
    TResult Function(_SetSubtopic value)? setSubtopic,
    TResult Function(_NextStep value)? nextStep,
    TResult Function(_GoSuccessfulScreen value)? goSuccessfulScreen,
    TResult Function(_CantHear value)? cantHear,
    TResult Function(_CantSpeak value)? cantSpeak,
    TResult Function(_ZeroHealth value)? zeroHealth,
    TResult Function(_StartStudy value)? startStudy,
    required TResult orElse(),
  }) {
    if (goSuccessfulScreen != null) {
      return goSuccessfulScreen(this);
    }
    return orElse();
  }
}

abstract class _GoSuccessfulScreen implements TrainingEvent {
  const factory _GoSuccessfulScreen() = _$GoSuccessfulScreenImpl;
}

/// @nodoc
abstract class _$$CantHearImplCopyWith<$Res> {
  factory _$$CantHearImplCopyWith(
          _$CantHearImpl value, $Res Function(_$CantHearImpl) then) =
      __$$CantHearImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$CantHearImplCopyWithImpl<$Res>
    extends _$TrainingEventCopyWithImpl<$Res, _$CantHearImpl>
    implements _$$CantHearImplCopyWith<$Res> {
  __$$CantHearImplCopyWithImpl(
      _$CantHearImpl _value, $Res Function(_$CantHearImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$CantHearImpl implements _CantHear {
  const _$CantHearImpl();

  @override
  String toString() {
    return 'TrainingEvent.cantHear()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$CantHearImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Topic topic) setTopic,
    required TResult Function(Subtopic subtopic) setSubtopic,
    required TResult Function() nextStep,
    required TResult Function() goSuccessfulScreen,
    required TResult Function() cantHear,
    required TResult Function() cantSpeak,
    required TResult Function() zeroHealth,
    required TResult Function(Subtopic subtopic) startStudy,
  }) {
    return cantHear();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Topic topic)? setTopic,
    TResult? Function(Subtopic subtopic)? setSubtopic,
    TResult? Function()? nextStep,
    TResult? Function()? goSuccessfulScreen,
    TResult? Function()? cantHear,
    TResult? Function()? cantSpeak,
    TResult? Function()? zeroHealth,
    TResult? Function(Subtopic subtopic)? startStudy,
  }) {
    return cantHear?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Topic topic)? setTopic,
    TResult Function(Subtopic subtopic)? setSubtopic,
    TResult Function()? nextStep,
    TResult Function()? goSuccessfulScreen,
    TResult Function()? cantHear,
    TResult Function()? cantSpeak,
    TResult Function()? zeroHealth,
    TResult Function(Subtopic subtopic)? startStudy,
    required TResult orElse(),
  }) {
    if (cantHear != null) {
      return cantHear();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SetTopic value) setTopic,
    required TResult Function(_SetSubtopic value) setSubtopic,
    required TResult Function(_NextStep value) nextStep,
    required TResult Function(_GoSuccessfulScreen value) goSuccessfulScreen,
    required TResult Function(_CantHear value) cantHear,
    required TResult Function(_CantSpeak value) cantSpeak,
    required TResult Function(_ZeroHealth value) zeroHealth,
    required TResult Function(_StartStudy value) startStudy,
  }) {
    return cantHear(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SetTopic value)? setTopic,
    TResult? Function(_SetSubtopic value)? setSubtopic,
    TResult? Function(_NextStep value)? nextStep,
    TResult? Function(_GoSuccessfulScreen value)? goSuccessfulScreen,
    TResult? Function(_CantHear value)? cantHear,
    TResult? Function(_CantSpeak value)? cantSpeak,
    TResult? Function(_ZeroHealth value)? zeroHealth,
    TResult? Function(_StartStudy value)? startStudy,
  }) {
    return cantHear?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SetTopic value)? setTopic,
    TResult Function(_SetSubtopic value)? setSubtopic,
    TResult Function(_NextStep value)? nextStep,
    TResult Function(_GoSuccessfulScreen value)? goSuccessfulScreen,
    TResult Function(_CantHear value)? cantHear,
    TResult Function(_CantSpeak value)? cantSpeak,
    TResult Function(_ZeroHealth value)? zeroHealth,
    TResult Function(_StartStudy value)? startStudy,
    required TResult orElse(),
  }) {
    if (cantHear != null) {
      return cantHear(this);
    }
    return orElse();
  }
}

abstract class _CantHear implements TrainingEvent {
  const factory _CantHear() = _$CantHearImpl;
}

/// @nodoc
abstract class _$$CantSpeakImplCopyWith<$Res> {
  factory _$$CantSpeakImplCopyWith(
          _$CantSpeakImpl value, $Res Function(_$CantSpeakImpl) then) =
      __$$CantSpeakImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$CantSpeakImplCopyWithImpl<$Res>
    extends _$TrainingEventCopyWithImpl<$Res, _$CantSpeakImpl>
    implements _$$CantSpeakImplCopyWith<$Res> {
  __$$CantSpeakImplCopyWithImpl(
      _$CantSpeakImpl _value, $Res Function(_$CantSpeakImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$CantSpeakImpl implements _CantSpeak {
  const _$CantSpeakImpl();

  @override
  String toString() {
    return 'TrainingEvent.cantSpeak()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$CantSpeakImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Topic topic) setTopic,
    required TResult Function(Subtopic subtopic) setSubtopic,
    required TResult Function() nextStep,
    required TResult Function() goSuccessfulScreen,
    required TResult Function() cantHear,
    required TResult Function() cantSpeak,
    required TResult Function() zeroHealth,
    required TResult Function(Subtopic subtopic) startStudy,
  }) {
    return cantSpeak();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Topic topic)? setTopic,
    TResult? Function(Subtopic subtopic)? setSubtopic,
    TResult? Function()? nextStep,
    TResult? Function()? goSuccessfulScreen,
    TResult? Function()? cantHear,
    TResult? Function()? cantSpeak,
    TResult? Function()? zeroHealth,
    TResult? Function(Subtopic subtopic)? startStudy,
  }) {
    return cantSpeak?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Topic topic)? setTopic,
    TResult Function(Subtopic subtopic)? setSubtopic,
    TResult Function()? nextStep,
    TResult Function()? goSuccessfulScreen,
    TResult Function()? cantHear,
    TResult Function()? cantSpeak,
    TResult Function()? zeroHealth,
    TResult Function(Subtopic subtopic)? startStudy,
    required TResult orElse(),
  }) {
    if (cantSpeak != null) {
      return cantSpeak();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SetTopic value) setTopic,
    required TResult Function(_SetSubtopic value) setSubtopic,
    required TResult Function(_NextStep value) nextStep,
    required TResult Function(_GoSuccessfulScreen value) goSuccessfulScreen,
    required TResult Function(_CantHear value) cantHear,
    required TResult Function(_CantSpeak value) cantSpeak,
    required TResult Function(_ZeroHealth value) zeroHealth,
    required TResult Function(_StartStudy value) startStudy,
  }) {
    return cantSpeak(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SetTopic value)? setTopic,
    TResult? Function(_SetSubtopic value)? setSubtopic,
    TResult? Function(_NextStep value)? nextStep,
    TResult? Function(_GoSuccessfulScreen value)? goSuccessfulScreen,
    TResult? Function(_CantHear value)? cantHear,
    TResult? Function(_CantSpeak value)? cantSpeak,
    TResult? Function(_ZeroHealth value)? zeroHealth,
    TResult? Function(_StartStudy value)? startStudy,
  }) {
    return cantSpeak?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SetTopic value)? setTopic,
    TResult Function(_SetSubtopic value)? setSubtopic,
    TResult Function(_NextStep value)? nextStep,
    TResult Function(_GoSuccessfulScreen value)? goSuccessfulScreen,
    TResult Function(_CantHear value)? cantHear,
    TResult Function(_CantSpeak value)? cantSpeak,
    TResult Function(_ZeroHealth value)? zeroHealth,
    TResult Function(_StartStudy value)? startStudy,
    required TResult orElse(),
  }) {
    if (cantSpeak != null) {
      return cantSpeak(this);
    }
    return orElse();
  }
}

abstract class _CantSpeak implements TrainingEvent {
  const factory _CantSpeak() = _$CantSpeakImpl;
}

/// @nodoc
abstract class _$$ZeroHealthImplCopyWith<$Res> {
  factory _$$ZeroHealthImplCopyWith(
          _$ZeroHealthImpl value, $Res Function(_$ZeroHealthImpl) then) =
      __$$ZeroHealthImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ZeroHealthImplCopyWithImpl<$Res>
    extends _$TrainingEventCopyWithImpl<$Res, _$ZeroHealthImpl>
    implements _$$ZeroHealthImplCopyWith<$Res> {
  __$$ZeroHealthImplCopyWithImpl(
      _$ZeroHealthImpl _value, $Res Function(_$ZeroHealthImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ZeroHealthImpl implements _ZeroHealth {
  const _$ZeroHealthImpl();

  @override
  String toString() {
    return 'TrainingEvent.zeroHealth()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ZeroHealthImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Topic topic) setTopic,
    required TResult Function(Subtopic subtopic) setSubtopic,
    required TResult Function() nextStep,
    required TResult Function() goSuccessfulScreen,
    required TResult Function() cantHear,
    required TResult Function() cantSpeak,
    required TResult Function() zeroHealth,
    required TResult Function(Subtopic subtopic) startStudy,
  }) {
    return zeroHealth();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Topic topic)? setTopic,
    TResult? Function(Subtopic subtopic)? setSubtopic,
    TResult? Function()? nextStep,
    TResult? Function()? goSuccessfulScreen,
    TResult? Function()? cantHear,
    TResult? Function()? cantSpeak,
    TResult? Function()? zeroHealth,
    TResult? Function(Subtopic subtopic)? startStudy,
  }) {
    return zeroHealth?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Topic topic)? setTopic,
    TResult Function(Subtopic subtopic)? setSubtopic,
    TResult Function()? nextStep,
    TResult Function()? goSuccessfulScreen,
    TResult Function()? cantHear,
    TResult Function()? cantSpeak,
    TResult Function()? zeroHealth,
    TResult Function(Subtopic subtopic)? startStudy,
    required TResult orElse(),
  }) {
    if (zeroHealth != null) {
      return zeroHealth();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SetTopic value) setTopic,
    required TResult Function(_SetSubtopic value) setSubtopic,
    required TResult Function(_NextStep value) nextStep,
    required TResult Function(_GoSuccessfulScreen value) goSuccessfulScreen,
    required TResult Function(_CantHear value) cantHear,
    required TResult Function(_CantSpeak value) cantSpeak,
    required TResult Function(_ZeroHealth value) zeroHealth,
    required TResult Function(_StartStudy value) startStudy,
  }) {
    return zeroHealth(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SetTopic value)? setTopic,
    TResult? Function(_SetSubtopic value)? setSubtopic,
    TResult? Function(_NextStep value)? nextStep,
    TResult? Function(_GoSuccessfulScreen value)? goSuccessfulScreen,
    TResult? Function(_CantHear value)? cantHear,
    TResult? Function(_CantSpeak value)? cantSpeak,
    TResult? Function(_ZeroHealth value)? zeroHealth,
    TResult? Function(_StartStudy value)? startStudy,
  }) {
    return zeroHealth?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SetTopic value)? setTopic,
    TResult Function(_SetSubtopic value)? setSubtopic,
    TResult Function(_NextStep value)? nextStep,
    TResult Function(_GoSuccessfulScreen value)? goSuccessfulScreen,
    TResult Function(_CantHear value)? cantHear,
    TResult Function(_CantSpeak value)? cantSpeak,
    TResult Function(_ZeroHealth value)? zeroHealth,
    TResult Function(_StartStudy value)? startStudy,
    required TResult orElse(),
  }) {
    if (zeroHealth != null) {
      return zeroHealth(this);
    }
    return orElse();
  }
}

abstract class _ZeroHealth implements TrainingEvent {
  const factory _ZeroHealth() = _$ZeroHealthImpl;
}

/// @nodoc
abstract class _$$StartStudyImplCopyWith<$Res> {
  factory _$$StartStudyImplCopyWith(
          _$StartStudyImpl value, $Res Function(_$StartStudyImpl) then) =
      __$$StartStudyImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Subtopic subtopic});
}

/// @nodoc
class __$$StartStudyImplCopyWithImpl<$Res>
    extends _$TrainingEventCopyWithImpl<$Res, _$StartStudyImpl>
    implements _$$StartStudyImplCopyWith<$Res> {
  __$$StartStudyImplCopyWithImpl(
      _$StartStudyImpl _value, $Res Function(_$StartStudyImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? subtopic = null,
  }) {
    return _then(_$StartStudyImpl(
      null == subtopic
          ? _value.subtopic
          : subtopic // ignore: cast_nullable_to_non_nullable
              as Subtopic,
    ));
  }
}

/// @nodoc

class _$StartStudyImpl implements _StartStudy {
  const _$StartStudyImpl(this.subtopic);

  @override
  final Subtopic subtopic;

  @override
  String toString() {
    return 'TrainingEvent.startStudy(subtopic: $subtopic)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$StartStudyImpl &&
            (identical(other.subtopic, subtopic) ||
                other.subtopic == subtopic));
  }

  @override
  int get hashCode => Object.hash(runtimeType, subtopic);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$StartStudyImplCopyWith<_$StartStudyImpl> get copyWith =>
      __$$StartStudyImplCopyWithImpl<_$StartStudyImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Topic topic) setTopic,
    required TResult Function(Subtopic subtopic) setSubtopic,
    required TResult Function() nextStep,
    required TResult Function() goSuccessfulScreen,
    required TResult Function() cantHear,
    required TResult Function() cantSpeak,
    required TResult Function() zeroHealth,
    required TResult Function(Subtopic subtopic) startStudy,
  }) {
    return startStudy(subtopic);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Topic topic)? setTopic,
    TResult? Function(Subtopic subtopic)? setSubtopic,
    TResult? Function()? nextStep,
    TResult? Function()? goSuccessfulScreen,
    TResult? Function()? cantHear,
    TResult? Function()? cantSpeak,
    TResult? Function()? zeroHealth,
    TResult? Function(Subtopic subtopic)? startStudy,
  }) {
    return startStudy?.call(subtopic);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Topic topic)? setTopic,
    TResult Function(Subtopic subtopic)? setSubtopic,
    TResult Function()? nextStep,
    TResult Function()? goSuccessfulScreen,
    TResult Function()? cantHear,
    TResult Function()? cantSpeak,
    TResult Function()? zeroHealth,
    TResult Function(Subtopic subtopic)? startStudy,
    required TResult orElse(),
  }) {
    if (startStudy != null) {
      return startStudy(subtopic);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_SetTopic value) setTopic,
    required TResult Function(_SetSubtopic value) setSubtopic,
    required TResult Function(_NextStep value) nextStep,
    required TResult Function(_GoSuccessfulScreen value) goSuccessfulScreen,
    required TResult Function(_CantHear value) cantHear,
    required TResult Function(_CantSpeak value) cantSpeak,
    required TResult Function(_ZeroHealth value) zeroHealth,
    required TResult Function(_StartStudy value) startStudy,
  }) {
    return startStudy(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_SetTopic value)? setTopic,
    TResult? Function(_SetSubtopic value)? setSubtopic,
    TResult? Function(_NextStep value)? nextStep,
    TResult? Function(_GoSuccessfulScreen value)? goSuccessfulScreen,
    TResult? Function(_CantHear value)? cantHear,
    TResult? Function(_CantSpeak value)? cantSpeak,
    TResult? Function(_ZeroHealth value)? zeroHealth,
    TResult? Function(_StartStudy value)? startStudy,
  }) {
    return startStudy?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_SetTopic value)? setTopic,
    TResult Function(_SetSubtopic value)? setSubtopic,
    TResult Function(_NextStep value)? nextStep,
    TResult Function(_GoSuccessfulScreen value)? goSuccessfulScreen,
    TResult Function(_CantHear value)? cantHear,
    TResult Function(_CantSpeak value)? cantSpeak,
    TResult Function(_ZeroHealth value)? zeroHealth,
    TResult Function(_StartStudy value)? startStudy,
    required TResult orElse(),
  }) {
    if (startStudy != null) {
      return startStudy(this);
    }
    return orElse();
  }
}

abstract class _StartStudy implements TrainingEvent {
  const factory _StartStudy(final Subtopic subtopic) = _$StartStudyImpl;

  Subtopic get subtopic;
  @JsonKey(ignore: true)
  _$$StartStudyImplCopyWith<_$StartStudyImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
