// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'subscription_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$SubscriptionEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() downloadSubcriptionsTypes,
    required TResult Function(Tariff tariff) paySubscription,
    required TResult Function() checkSubscription,
    required TResult Function() isSubscriptionActive,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? downloadSubcriptionsTypes,
    TResult? Function(Tariff tariff)? paySubscription,
    TResult? Function()? checkSubscription,
    TResult? Function()? isSubscriptionActive,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? downloadSubcriptionsTypes,
    TResult Function(Tariff tariff)? paySubscription,
    TResult Function()? checkSubscription,
    TResult Function()? isSubscriptionActive,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_DownloadSubscriptionTypes value)
        downloadSubcriptionsTypes,
    required TResult Function(_PaySubscription value) paySubscription,
    required TResult Function(_CheckSubscription value) checkSubscription,
    required TResult Function(_IsSubscriptionActive value) isSubscriptionActive,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_DownloadSubscriptionTypes value)?
        downloadSubcriptionsTypes,
    TResult? Function(_PaySubscription value)? paySubscription,
    TResult? Function(_CheckSubscription value)? checkSubscription,
    TResult? Function(_IsSubscriptionActive value)? isSubscriptionActive,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_DownloadSubscriptionTypes value)?
        downloadSubcriptionsTypes,
    TResult Function(_PaySubscription value)? paySubscription,
    TResult Function(_CheckSubscription value)? checkSubscription,
    TResult Function(_IsSubscriptionActive value)? isSubscriptionActive,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubscriptionEventCopyWith<$Res> {
  factory $SubscriptionEventCopyWith(
          SubscriptionEvent value, $Res Function(SubscriptionEvent) then) =
      _$SubscriptionEventCopyWithImpl<$Res, SubscriptionEvent>;
}

/// @nodoc
class _$SubscriptionEventCopyWithImpl<$Res, $Val extends SubscriptionEvent>
    implements $SubscriptionEventCopyWith<$Res> {
  _$SubscriptionEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$DownloadSubscriptionTypesImplCopyWith<$Res> {
  factory _$$DownloadSubscriptionTypesImplCopyWith(
          _$DownloadSubscriptionTypesImpl value,
          $Res Function(_$DownloadSubscriptionTypesImpl) then) =
      __$$DownloadSubscriptionTypesImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DownloadSubscriptionTypesImplCopyWithImpl<$Res>
    extends _$SubscriptionEventCopyWithImpl<$Res,
        _$DownloadSubscriptionTypesImpl>
    implements _$$DownloadSubscriptionTypesImplCopyWith<$Res> {
  __$$DownloadSubscriptionTypesImplCopyWithImpl(
      _$DownloadSubscriptionTypesImpl _value,
      $Res Function(_$DownloadSubscriptionTypesImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DownloadSubscriptionTypesImpl implements _DownloadSubscriptionTypes {
  const _$DownloadSubscriptionTypesImpl();

  @override
  String toString() {
    return 'SubscriptionEvent.downloadSubcriptionsTypes()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DownloadSubscriptionTypesImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() downloadSubcriptionsTypes,
    required TResult Function(Tariff tariff) paySubscription,
    required TResult Function() checkSubscription,
    required TResult Function() isSubscriptionActive,
  }) {
    return downloadSubcriptionsTypes();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? downloadSubcriptionsTypes,
    TResult? Function(Tariff tariff)? paySubscription,
    TResult? Function()? checkSubscription,
    TResult? Function()? isSubscriptionActive,
  }) {
    return downloadSubcriptionsTypes?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? downloadSubcriptionsTypes,
    TResult Function(Tariff tariff)? paySubscription,
    TResult Function()? checkSubscription,
    TResult Function()? isSubscriptionActive,
    required TResult orElse(),
  }) {
    if (downloadSubcriptionsTypes != null) {
      return downloadSubcriptionsTypes();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_DownloadSubscriptionTypes value)
        downloadSubcriptionsTypes,
    required TResult Function(_PaySubscription value) paySubscription,
    required TResult Function(_CheckSubscription value) checkSubscription,
    required TResult Function(_IsSubscriptionActive value) isSubscriptionActive,
  }) {
    return downloadSubcriptionsTypes(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_DownloadSubscriptionTypes value)?
        downloadSubcriptionsTypes,
    TResult? Function(_PaySubscription value)? paySubscription,
    TResult? Function(_CheckSubscription value)? checkSubscription,
    TResult? Function(_IsSubscriptionActive value)? isSubscriptionActive,
  }) {
    return downloadSubcriptionsTypes?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_DownloadSubscriptionTypes value)?
        downloadSubcriptionsTypes,
    TResult Function(_PaySubscription value)? paySubscription,
    TResult Function(_CheckSubscription value)? checkSubscription,
    TResult Function(_IsSubscriptionActive value)? isSubscriptionActive,
    required TResult orElse(),
  }) {
    if (downloadSubcriptionsTypes != null) {
      return downloadSubcriptionsTypes(this);
    }
    return orElse();
  }
}

abstract class _DownloadSubscriptionTypes implements SubscriptionEvent {
  const factory _DownloadSubscriptionTypes() = _$DownloadSubscriptionTypesImpl;
}

/// @nodoc
abstract class _$$PaySubscriptionImplCopyWith<$Res> {
  factory _$$PaySubscriptionImplCopyWith(_$PaySubscriptionImpl value,
          $Res Function(_$PaySubscriptionImpl) then) =
      __$$PaySubscriptionImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Tariff tariff});
}

/// @nodoc
class __$$PaySubscriptionImplCopyWithImpl<$Res>
    extends _$SubscriptionEventCopyWithImpl<$Res, _$PaySubscriptionImpl>
    implements _$$PaySubscriptionImplCopyWith<$Res> {
  __$$PaySubscriptionImplCopyWithImpl(
      _$PaySubscriptionImpl _value, $Res Function(_$PaySubscriptionImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? tariff = null,
  }) {
    return _then(_$PaySubscriptionImpl(
      null == tariff
          ? _value.tariff
          : tariff // ignore: cast_nullable_to_non_nullable
              as Tariff,
    ));
  }
}

/// @nodoc

class _$PaySubscriptionImpl implements _PaySubscription {
  const _$PaySubscriptionImpl(this.tariff);

  @override
  final Tariff tariff;

  @override
  String toString() {
    return 'SubscriptionEvent.paySubscription(tariff: $tariff)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PaySubscriptionImpl &&
            (identical(other.tariff, tariff) || other.tariff == tariff));
  }

  @override
  int get hashCode => Object.hash(runtimeType, tariff);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PaySubscriptionImplCopyWith<_$PaySubscriptionImpl> get copyWith =>
      __$$PaySubscriptionImplCopyWithImpl<_$PaySubscriptionImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() downloadSubcriptionsTypes,
    required TResult Function(Tariff tariff) paySubscription,
    required TResult Function() checkSubscription,
    required TResult Function() isSubscriptionActive,
  }) {
    return paySubscription(tariff);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? downloadSubcriptionsTypes,
    TResult? Function(Tariff tariff)? paySubscription,
    TResult? Function()? checkSubscription,
    TResult? Function()? isSubscriptionActive,
  }) {
    return paySubscription?.call(tariff);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? downloadSubcriptionsTypes,
    TResult Function(Tariff tariff)? paySubscription,
    TResult Function()? checkSubscription,
    TResult Function()? isSubscriptionActive,
    required TResult orElse(),
  }) {
    if (paySubscription != null) {
      return paySubscription(tariff);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_DownloadSubscriptionTypes value)
        downloadSubcriptionsTypes,
    required TResult Function(_PaySubscription value) paySubscription,
    required TResult Function(_CheckSubscription value) checkSubscription,
    required TResult Function(_IsSubscriptionActive value) isSubscriptionActive,
  }) {
    return paySubscription(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_DownloadSubscriptionTypes value)?
        downloadSubcriptionsTypes,
    TResult? Function(_PaySubscription value)? paySubscription,
    TResult? Function(_CheckSubscription value)? checkSubscription,
    TResult? Function(_IsSubscriptionActive value)? isSubscriptionActive,
  }) {
    return paySubscription?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_DownloadSubscriptionTypes value)?
        downloadSubcriptionsTypes,
    TResult Function(_PaySubscription value)? paySubscription,
    TResult Function(_CheckSubscription value)? checkSubscription,
    TResult Function(_IsSubscriptionActive value)? isSubscriptionActive,
    required TResult orElse(),
  }) {
    if (paySubscription != null) {
      return paySubscription(this);
    }
    return orElse();
  }
}

abstract class _PaySubscription implements SubscriptionEvent {
  const factory _PaySubscription(final Tariff tariff) = _$PaySubscriptionImpl;

  Tariff get tariff;
  @JsonKey(ignore: true)
  _$$PaySubscriptionImplCopyWith<_$PaySubscriptionImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CheckSubscriptionImplCopyWith<$Res> {
  factory _$$CheckSubscriptionImplCopyWith(_$CheckSubscriptionImpl value,
          $Res Function(_$CheckSubscriptionImpl) then) =
      __$$CheckSubscriptionImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$CheckSubscriptionImplCopyWithImpl<$Res>
    extends _$SubscriptionEventCopyWithImpl<$Res, _$CheckSubscriptionImpl>
    implements _$$CheckSubscriptionImplCopyWith<$Res> {
  __$$CheckSubscriptionImplCopyWithImpl(_$CheckSubscriptionImpl _value,
      $Res Function(_$CheckSubscriptionImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$CheckSubscriptionImpl implements _CheckSubscription {
  const _$CheckSubscriptionImpl();

  @override
  String toString() {
    return 'SubscriptionEvent.checkSubscription()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$CheckSubscriptionImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() downloadSubcriptionsTypes,
    required TResult Function(Tariff tariff) paySubscription,
    required TResult Function() checkSubscription,
    required TResult Function() isSubscriptionActive,
  }) {
    return checkSubscription();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? downloadSubcriptionsTypes,
    TResult? Function(Tariff tariff)? paySubscription,
    TResult? Function()? checkSubscription,
    TResult? Function()? isSubscriptionActive,
  }) {
    return checkSubscription?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? downloadSubcriptionsTypes,
    TResult Function(Tariff tariff)? paySubscription,
    TResult Function()? checkSubscription,
    TResult Function()? isSubscriptionActive,
    required TResult orElse(),
  }) {
    if (checkSubscription != null) {
      return checkSubscription();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_DownloadSubscriptionTypes value)
        downloadSubcriptionsTypes,
    required TResult Function(_PaySubscription value) paySubscription,
    required TResult Function(_CheckSubscription value) checkSubscription,
    required TResult Function(_IsSubscriptionActive value) isSubscriptionActive,
  }) {
    return checkSubscription(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_DownloadSubscriptionTypes value)?
        downloadSubcriptionsTypes,
    TResult? Function(_PaySubscription value)? paySubscription,
    TResult? Function(_CheckSubscription value)? checkSubscription,
    TResult? Function(_IsSubscriptionActive value)? isSubscriptionActive,
  }) {
    return checkSubscription?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_DownloadSubscriptionTypes value)?
        downloadSubcriptionsTypes,
    TResult Function(_PaySubscription value)? paySubscription,
    TResult Function(_CheckSubscription value)? checkSubscription,
    TResult Function(_IsSubscriptionActive value)? isSubscriptionActive,
    required TResult orElse(),
  }) {
    if (checkSubscription != null) {
      return checkSubscription(this);
    }
    return orElse();
  }
}

abstract class _CheckSubscription implements SubscriptionEvent {
  const factory _CheckSubscription() = _$CheckSubscriptionImpl;
}

/// @nodoc
abstract class _$$IsSubscriptionActiveImplCopyWith<$Res> {
  factory _$$IsSubscriptionActiveImplCopyWith(_$IsSubscriptionActiveImpl value,
          $Res Function(_$IsSubscriptionActiveImpl) then) =
      __$$IsSubscriptionActiveImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$IsSubscriptionActiveImplCopyWithImpl<$Res>
    extends _$SubscriptionEventCopyWithImpl<$Res, _$IsSubscriptionActiveImpl>
    implements _$$IsSubscriptionActiveImplCopyWith<$Res> {
  __$$IsSubscriptionActiveImplCopyWithImpl(_$IsSubscriptionActiveImpl _value,
      $Res Function(_$IsSubscriptionActiveImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$IsSubscriptionActiveImpl implements _IsSubscriptionActive {
  const _$IsSubscriptionActiveImpl();

  @override
  String toString() {
    return 'SubscriptionEvent.isSubscriptionActive()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$IsSubscriptionActiveImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() downloadSubcriptionsTypes,
    required TResult Function(Tariff tariff) paySubscription,
    required TResult Function() checkSubscription,
    required TResult Function() isSubscriptionActive,
  }) {
    return isSubscriptionActive();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? downloadSubcriptionsTypes,
    TResult? Function(Tariff tariff)? paySubscription,
    TResult? Function()? checkSubscription,
    TResult? Function()? isSubscriptionActive,
  }) {
    return isSubscriptionActive?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? downloadSubcriptionsTypes,
    TResult Function(Tariff tariff)? paySubscription,
    TResult Function()? checkSubscription,
    TResult Function()? isSubscriptionActive,
    required TResult orElse(),
  }) {
    if (isSubscriptionActive != null) {
      return isSubscriptionActive();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_DownloadSubscriptionTypes value)
        downloadSubcriptionsTypes,
    required TResult Function(_PaySubscription value) paySubscription,
    required TResult Function(_CheckSubscription value) checkSubscription,
    required TResult Function(_IsSubscriptionActive value) isSubscriptionActive,
  }) {
    return isSubscriptionActive(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_DownloadSubscriptionTypes value)?
        downloadSubcriptionsTypes,
    TResult? Function(_PaySubscription value)? paySubscription,
    TResult? Function(_CheckSubscription value)? checkSubscription,
    TResult? Function(_IsSubscriptionActive value)? isSubscriptionActive,
  }) {
    return isSubscriptionActive?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_DownloadSubscriptionTypes value)?
        downloadSubcriptionsTypes,
    TResult Function(_PaySubscription value)? paySubscription,
    TResult Function(_CheckSubscription value)? checkSubscription,
    TResult Function(_IsSubscriptionActive value)? isSubscriptionActive,
    required TResult orElse(),
  }) {
    if (isSubscriptionActive != null) {
      return isSubscriptionActive(this);
    }
    return orElse();
  }
}

abstract class _IsSubscriptionActive implements SubscriptionEvent {
  const factory _IsSubscriptionActive() = _$IsSubscriptionActiveImpl;
}

/// @nodoc
mixin _$SubscriptionState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<Tariff> tariffs) initial,
    required TResult Function() loading,
    required TResult Function() subscriptionPaid,
    required TResult Function() subscriptionNotPaid,
    required TResult Function(String paymentLink) payingSubscription,
    required TResult Function(SubscriptionCheckStatus failed) falied,
    required TResult Function(SubscriptionCheckStatus success) success,
    required TResult Function(bool isActive, String date) subscriptionStatus,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<Tariff> tariffs)? initial,
    TResult? Function()? loading,
    TResult? Function()? subscriptionPaid,
    TResult? Function()? subscriptionNotPaid,
    TResult? Function(String paymentLink)? payingSubscription,
    TResult? Function(SubscriptionCheckStatus failed)? falied,
    TResult? Function(SubscriptionCheckStatus success)? success,
    TResult? Function(bool isActive, String date)? subscriptionStatus,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<Tariff> tariffs)? initial,
    TResult Function()? loading,
    TResult Function()? subscriptionPaid,
    TResult Function()? subscriptionNotPaid,
    TResult Function(String paymentLink)? payingSubscription,
    TResult Function(SubscriptionCheckStatus failed)? falied,
    TResult Function(SubscriptionCheckStatus success)? success,
    TResult Function(bool isActive, String date)? subscriptionStatus,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_SubscriptionPaid value) subscriptionPaid,
    required TResult Function(_SubscriptionNotPaid value) subscriptionNotPaid,
    required TResult Function(_PayingSubscription value) payingSubscription,
    required TResult Function(_Failed value) falied,
    required TResult Function(_Success value) success,
    required TResult Function(_SubscriptionStatus value) subscriptionStatus,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_SubscriptionPaid value)? subscriptionPaid,
    TResult? Function(_SubscriptionNotPaid value)? subscriptionNotPaid,
    TResult? Function(_PayingSubscription value)? payingSubscription,
    TResult? Function(_Failed value)? falied,
    TResult? Function(_Success value)? success,
    TResult? Function(_SubscriptionStatus value)? subscriptionStatus,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_SubscriptionPaid value)? subscriptionPaid,
    TResult Function(_SubscriptionNotPaid value)? subscriptionNotPaid,
    TResult Function(_PayingSubscription value)? payingSubscription,
    TResult Function(_Failed value)? falied,
    TResult Function(_Success value)? success,
    TResult Function(_SubscriptionStatus value)? subscriptionStatus,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubscriptionStateCopyWith<$Res> {
  factory $SubscriptionStateCopyWith(
          SubscriptionState value, $Res Function(SubscriptionState) then) =
      _$SubscriptionStateCopyWithImpl<$Res, SubscriptionState>;
}

/// @nodoc
class _$SubscriptionStateCopyWithImpl<$Res, $Val extends SubscriptionState>
    implements $SubscriptionStateCopyWith<$Res> {
  _$SubscriptionStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$InitialImplCopyWith<$Res> {
  factory _$$InitialImplCopyWith(
          _$InitialImpl value, $Res Function(_$InitialImpl) then) =
      __$$InitialImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<Tariff> tariffs});
}

/// @nodoc
class __$$InitialImplCopyWithImpl<$Res>
    extends _$SubscriptionStateCopyWithImpl<$Res, _$InitialImpl>
    implements _$$InitialImplCopyWith<$Res> {
  __$$InitialImplCopyWithImpl(
      _$InitialImpl _value, $Res Function(_$InitialImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? tariffs = null,
  }) {
    return _then(_$InitialImpl(
      null == tariffs
          ? _value._tariffs
          : tariffs // ignore: cast_nullable_to_non_nullable
              as List<Tariff>,
    ));
  }
}

/// @nodoc

class _$InitialImpl implements _Initial {
  const _$InitialImpl(final List<Tariff> tariffs) : _tariffs = tariffs;

  final List<Tariff> _tariffs;
  @override
  List<Tariff> get tariffs {
    if (_tariffs is EqualUnmodifiableListView) return _tariffs;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_tariffs);
  }

  @override
  String toString() {
    return 'SubscriptionState.initial(tariffs: $tariffs)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InitialImpl &&
            const DeepCollectionEquality().equals(other._tariffs, _tariffs));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_tariffs));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$InitialImplCopyWith<_$InitialImpl> get copyWith =>
      __$$InitialImplCopyWithImpl<_$InitialImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<Tariff> tariffs) initial,
    required TResult Function() loading,
    required TResult Function() subscriptionPaid,
    required TResult Function() subscriptionNotPaid,
    required TResult Function(String paymentLink) payingSubscription,
    required TResult Function(SubscriptionCheckStatus failed) falied,
    required TResult Function(SubscriptionCheckStatus success) success,
    required TResult Function(bool isActive, String date) subscriptionStatus,
  }) {
    return initial(tariffs);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<Tariff> tariffs)? initial,
    TResult? Function()? loading,
    TResult? Function()? subscriptionPaid,
    TResult? Function()? subscriptionNotPaid,
    TResult? Function(String paymentLink)? payingSubscription,
    TResult? Function(SubscriptionCheckStatus failed)? falied,
    TResult? Function(SubscriptionCheckStatus success)? success,
    TResult? Function(bool isActive, String date)? subscriptionStatus,
  }) {
    return initial?.call(tariffs);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<Tariff> tariffs)? initial,
    TResult Function()? loading,
    TResult Function()? subscriptionPaid,
    TResult Function()? subscriptionNotPaid,
    TResult Function(String paymentLink)? payingSubscription,
    TResult Function(SubscriptionCheckStatus failed)? falied,
    TResult Function(SubscriptionCheckStatus success)? success,
    TResult Function(bool isActive, String date)? subscriptionStatus,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(tariffs);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_SubscriptionPaid value) subscriptionPaid,
    required TResult Function(_SubscriptionNotPaid value) subscriptionNotPaid,
    required TResult Function(_PayingSubscription value) payingSubscription,
    required TResult Function(_Failed value) falied,
    required TResult Function(_Success value) success,
    required TResult Function(_SubscriptionStatus value) subscriptionStatus,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_SubscriptionPaid value)? subscriptionPaid,
    TResult? Function(_SubscriptionNotPaid value)? subscriptionNotPaid,
    TResult? Function(_PayingSubscription value)? payingSubscription,
    TResult? Function(_Failed value)? falied,
    TResult? Function(_Success value)? success,
    TResult? Function(_SubscriptionStatus value)? subscriptionStatus,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_SubscriptionPaid value)? subscriptionPaid,
    TResult Function(_SubscriptionNotPaid value)? subscriptionNotPaid,
    TResult Function(_PayingSubscription value)? payingSubscription,
    TResult Function(_Failed value)? falied,
    TResult Function(_Success value)? success,
    TResult Function(_SubscriptionStatus value)? subscriptionStatus,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _Initial implements SubscriptionState {
  const factory _Initial(final List<Tariff> tariffs) = _$InitialImpl;

  List<Tariff> get tariffs;
  @JsonKey(ignore: true)
  _$$InitialImplCopyWith<_$InitialImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LoadingImplCopyWith<$Res> {
  factory _$$LoadingImplCopyWith(
          _$LoadingImpl value, $Res Function(_$LoadingImpl) then) =
      __$$LoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoadingImplCopyWithImpl<$Res>
    extends _$SubscriptionStateCopyWithImpl<$Res, _$LoadingImpl>
    implements _$$LoadingImplCopyWith<$Res> {
  __$$LoadingImplCopyWithImpl(
      _$LoadingImpl _value, $Res Function(_$LoadingImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$LoadingImpl implements _Loading {
  const _$LoadingImpl();

  @override
  String toString() {
    return 'SubscriptionState.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<Tariff> tariffs) initial,
    required TResult Function() loading,
    required TResult Function() subscriptionPaid,
    required TResult Function() subscriptionNotPaid,
    required TResult Function(String paymentLink) payingSubscription,
    required TResult Function(SubscriptionCheckStatus failed) falied,
    required TResult Function(SubscriptionCheckStatus success) success,
    required TResult Function(bool isActive, String date) subscriptionStatus,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<Tariff> tariffs)? initial,
    TResult? Function()? loading,
    TResult? Function()? subscriptionPaid,
    TResult? Function()? subscriptionNotPaid,
    TResult? Function(String paymentLink)? payingSubscription,
    TResult? Function(SubscriptionCheckStatus failed)? falied,
    TResult? Function(SubscriptionCheckStatus success)? success,
    TResult? Function(bool isActive, String date)? subscriptionStatus,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<Tariff> tariffs)? initial,
    TResult Function()? loading,
    TResult Function()? subscriptionPaid,
    TResult Function()? subscriptionNotPaid,
    TResult Function(String paymentLink)? payingSubscription,
    TResult Function(SubscriptionCheckStatus failed)? falied,
    TResult Function(SubscriptionCheckStatus success)? success,
    TResult Function(bool isActive, String date)? subscriptionStatus,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_SubscriptionPaid value) subscriptionPaid,
    required TResult Function(_SubscriptionNotPaid value) subscriptionNotPaid,
    required TResult Function(_PayingSubscription value) payingSubscription,
    required TResult Function(_Failed value) falied,
    required TResult Function(_Success value) success,
    required TResult Function(_SubscriptionStatus value) subscriptionStatus,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_SubscriptionPaid value)? subscriptionPaid,
    TResult? Function(_SubscriptionNotPaid value)? subscriptionNotPaid,
    TResult? Function(_PayingSubscription value)? payingSubscription,
    TResult? Function(_Failed value)? falied,
    TResult? Function(_Success value)? success,
    TResult? Function(_SubscriptionStatus value)? subscriptionStatus,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_SubscriptionPaid value)? subscriptionPaid,
    TResult Function(_SubscriptionNotPaid value)? subscriptionNotPaid,
    TResult Function(_PayingSubscription value)? payingSubscription,
    TResult Function(_Failed value)? falied,
    TResult Function(_Success value)? success,
    TResult Function(_SubscriptionStatus value)? subscriptionStatus,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _Loading implements SubscriptionState {
  const factory _Loading() = _$LoadingImpl;
}

/// @nodoc
abstract class _$$SubscriptionPaidImplCopyWith<$Res> {
  factory _$$SubscriptionPaidImplCopyWith(_$SubscriptionPaidImpl value,
          $Res Function(_$SubscriptionPaidImpl) then) =
      __$$SubscriptionPaidImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SubscriptionPaidImplCopyWithImpl<$Res>
    extends _$SubscriptionStateCopyWithImpl<$Res, _$SubscriptionPaidImpl>
    implements _$$SubscriptionPaidImplCopyWith<$Res> {
  __$$SubscriptionPaidImplCopyWithImpl(_$SubscriptionPaidImpl _value,
      $Res Function(_$SubscriptionPaidImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$SubscriptionPaidImpl implements _SubscriptionPaid {
  const _$SubscriptionPaidImpl();

  @override
  String toString() {
    return 'SubscriptionState.subscriptionPaid()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$SubscriptionPaidImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<Tariff> tariffs) initial,
    required TResult Function() loading,
    required TResult Function() subscriptionPaid,
    required TResult Function() subscriptionNotPaid,
    required TResult Function(String paymentLink) payingSubscription,
    required TResult Function(SubscriptionCheckStatus failed) falied,
    required TResult Function(SubscriptionCheckStatus success) success,
    required TResult Function(bool isActive, String date) subscriptionStatus,
  }) {
    return subscriptionPaid();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<Tariff> tariffs)? initial,
    TResult? Function()? loading,
    TResult? Function()? subscriptionPaid,
    TResult? Function()? subscriptionNotPaid,
    TResult? Function(String paymentLink)? payingSubscription,
    TResult? Function(SubscriptionCheckStatus failed)? falied,
    TResult? Function(SubscriptionCheckStatus success)? success,
    TResult? Function(bool isActive, String date)? subscriptionStatus,
  }) {
    return subscriptionPaid?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<Tariff> tariffs)? initial,
    TResult Function()? loading,
    TResult Function()? subscriptionPaid,
    TResult Function()? subscriptionNotPaid,
    TResult Function(String paymentLink)? payingSubscription,
    TResult Function(SubscriptionCheckStatus failed)? falied,
    TResult Function(SubscriptionCheckStatus success)? success,
    TResult Function(bool isActive, String date)? subscriptionStatus,
    required TResult orElse(),
  }) {
    if (subscriptionPaid != null) {
      return subscriptionPaid();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_SubscriptionPaid value) subscriptionPaid,
    required TResult Function(_SubscriptionNotPaid value) subscriptionNotPaid,
    required TResult Function(_PayingSubscription value) payingSubscription,
    required TResult Function(_Failed value) falied,
    required TResult Function(_Success value) success,
    required TResult Function(_SubscriptionStatus value) subscriptionStatus,
  }) {
    return subscriptionPaid(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_SubscriptionPaid value)? subscriptionPaid,
    TResult? Function(_SubscriptionNotPaid value)? subscriptionNotPaid,
    TResult? Function(_PayingSubscription value)? payingSubscription,
    TResult? Function(_Failed value)? falied,
    TResult? Function(_Success value)? success,
    TResult? Function(_SubscriptionStatus value)? subscriptionStatus,
  }) {
    return subscriptionPaid?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_SubscriptionPaid value)? subscriptionPaid,
    TResult Function(_SubscriptionNotPaid value)? subscriptionNotPaid,
    TResult Function(_PayingSubscription value)? payingSubscription,
    TResult Function(_Failed value)? falied,
    TResult Function(_Success value)? success,
    TResult Function(_SubscriptionStatus value)? subscriptionStatus,
    required TResult orElse(),
  }) {
    if (subscriptionPaid != null) {
      return subscriptionPaid(this);
    }
    return orElse();
  }
}

abstract class _SubscriptionPaid implements SubscriptionState {
  const factory _SubscriptionPaid() = _$SubscriptionPaidImpl;
}

/// @nodoc
abstract class _$$SubscriptionNotPaidImplCopyWith<$Res> {
  factory _$$SubscriptionNotPaidImplCopyWith(_$SubscriptionNotPaidImpl value,
          $Res Function(_$SubscriptionNotPaidImpl) then) =
      __$$SubscriptionNotPaidImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SubscriptionNotPaidImplCopyWithImpl<$Res>
    extends _$SubscriptionStateCopyWithImpl<$Res, _$SubscriptionNotPaidImpl>
    implements _$$SubscriptionNotPaidImplCopyWith<$Res> {
  __$$SubscriptionNotPaidImplCopyWithImpl(_$SubscriptionNotPaidImpl _value,
      $Res Function(_$SubscriptionNotPaidImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$SubscriptionNotPaidImpl implements _SubscriptionNotPaid {
  const _$SubscriptionNotPaidImpl();

  @override
  String toString() {
    return 'SubscriptionState.subscriptionNotPaid()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SubscriptionNotPaidImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<Tariff> tariffs) initial,
    required TResult Function() loading,
    required TResult Function() subscriptionPaid,
    required TResult Function() subscriptionNotPaid,
    required TResult Function(String paymentLink) payingSubscription,
    required TResult Function(SubscriptionCheckStatus failed) falied,
    required TResult Function(SubscriptionCheckStatus success) success,
    required TResult Function(bool isActive, String date) subscriptionStatus,
  }) {
    return subscriptionNotPaid();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<Tariff> tariffs)? initial,
    TResult? Function()? loading,
    TResult? Function()? subscriptionPaid,
    TResult? Function()? subscriptionNotPaid,
    TResult? Function(String paymentLink)? payingSubscription,
    TResult? Function(SubscriptionCheckStatus failed)? falied,
    TResult? Function(SubscriptionCheckStatus success)? success,
    TResult? Function(bool isActive, String date)? subscriptionStatus,
  }) {
    return subscriptionNotPaid?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<Tariff> tariffs)? initial,
    TResult Function()? loading,
    TResult Function()? subscriptionPaid,
    TResult Function()? subscriptionNotPaid,
    TResult Function(String paymentLink)? payingSubscription,
    TResult Function(SubscriptionCheckStatus failed)? falied,
    TResult Function(SubscriptionCheckStatus success)? success,
    TResult Function(bool isActive, String date)? subscriptionStatus,
    required TResult orElse(),
  }) {
    if (subscriptionNotPaid != null) {
      return subscriptionNotPaid();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_SubscriptionPaid value) subscriptionPaid,
    required TResult Function(_SubscriptionNotPaid value) subscriptionNotPaid,
    required TResult Function(_PayingSubscription value) payingSubscription,
    required TResult Function(_Failed value) falied,
    required TResult Function(_Success value) success,
    required TResult Function(_SubscriptionStatus value) subscriptionStatus,
  }) {
    return subscriptionNotPaid(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_SubscriptionPaid value)? subscriptionPaid,
    TResult? Function(_SubscriptionNotPaid value)? subscriptionNotPaid,
    TResult? Function(_PayingSubscription value)? payingSubscription,
    TResult? Function(_Failed value)? falied,
    TResult? Function(_Success value)? success,
    TResult? Function(_SubscriptionStatus value)? subscriptionStatus,
  }) {
    return subscriptionNotPaid?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_SubscriptionPaid value)? subscriptionPaid,
    TResult Function(_SubscriptionNotPaid value)? subscriptionNotPaid,
    TResult Function(_PayingSubscription value)? payingSubscription,
    TResult Function(_Failed value)? falied,
    TResult Function(_Success value)? success,
    TResult Function(_SubscriptionStatus value)? subscriptionStatus,
    required TResult orElse(),
  }) {
    if (subscriptionNotPaid != null) {
      return subscriptionNotPaid(this);
    }
    return orElse();
  }
}

abstract class _SubscriptionNotPaid implements SubscriptionState {
  const factory _SubscriptionNotPaid() = _$SubscriptionNotPaidImpl;
}

/// @nodoc
abstract class _$$PayingSubscriptionImplCopyWith<$Res> {
  factory _$$PayingSubscriptionImplCopyWith(_$PayingSubscriptionImpl value,
          $Res Function(_$PayingSubscriptionImpl) then) =
      __$$PayingSubscriptionImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String paymentLink});
}

/// @nodoc
class __$$PayingSubscriptionImplCopyWithImpl<$Res>
    extends _$SubscriptionStateCopyWithImpl<$Res, _$PayingSubscriptionImpl>
    implements _$$PayingSubscriptionImplCopyWith<$Res> {
  __$$PayingSubscriptionImplCopyWithImpl(_$PayingSubscriptionImpl _value,
      $Res Function(_$PayingSubscriptionImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? paymentLink = null,
  }) {
    return _then(_$PayingSubscriptionImpl(
      null == paymentLink
          ? _value.paymentLink
          : paymentLink // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$PayingSubscriptionImpl implements _PayingSubscription {
  const _$PayingSubscriptionImpl(this.paymentLink);

  @override
  final String paymentLink;

  @override
  String toString() {
    return 'SubscriptionState.payingSubscription(paymentLink: $paymentLink)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PayingSubscriptionImpl &&
            (identical(other.paymentLink, paymentLink) ||
                other.paymentLink == paymentLink));
  }

  @override
  int get hashCode => Object.hash(runtimeType, paymentLink);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PayingSubscriptionImplCopyWith<_$PayingSubscriptionImpl> get copyWith =>
      __$$PayingSubscriptionImplCopyWithImpl<_$PayingSubscriptionImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<Tariff> tariffs) initial,
    required TResult Function() loading,
    required TResult Function() subscriptionPaid,
    required TResult Function() subscriptionNotPaid,
    required TResult Function(String paymentLink) payingSubscription,
    required TResult Function(SubscriptionCheckStatus failed) falied,
    required TResult Function(SubscriptionCheckStatus success) success,
    required TResult Function(bool isActive, String date) subscriptionStatus,
  }) {
    return payingSubscription(paymentLink);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<Tariff> tariffs)? initial,
    TResult? Function()? loading,
    TResult? Function()? subscriptionPaid,
    TResult? Function()? subscriptionNotPaid,
    TResult? Function(String paymentLink)? payingSubscription,
    TResult? Function(SubscriptionCheckStatus failed)? falied,
    TResult? Function(SubscriptionCheckStatus success)? success,
    TResult? Function(bool isActive, String date)? subscriptionStatus,
  }) {
    return payingSubscription?.call(paymentLink);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<Tariff> tariffs)? initial,
    TResult Function()? loading,
    TResult Function()? subscriptionPaid,
    TResult Function()? subscriptionNotPaid,
    TResult Function(String paymentLink)? payingSubscription,
    TResult Function(SubscriptionCheckStatus failed)? falied,
    TResult Function(SubscriptionCheckStatus success)? success,
    TResult Function(bool isActive, String date)? subscriptionStatus,
    required TResult orElse(),
  }) {
    if (payingSubscription != null) {
      return payingSubscription(paymentLink);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_SubscriptionPaid value) subscriptionPaid,
    required TResult Function(_SubscriptionNotPaid value) subscriptionNotPaid,
    required TResult Function(_PayingSubscription value) payingSubscription,
    required TResult Function(_Failed value) falied,
    required TResult Function(_Success value) success,
    required TResult Function(_SubscriptionStatus value) subscriptionStatus,
  }) {
    return payingSubscription(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_SubscriptionPaid value)? subscriptionPaid,
    TResult? Function(_SubscriptionNotPaid value)? subscriptionNotPaid,
    TResult? Function(_PayingSubscription value)? payingSubscription,
    TResult? Function(_Failed value)? falied,
    TResult? Function(_Success value)? success,
    TResult? Function(_SubscriptionStatus value)? subscriptionStatus,
  }) {
    return payingSubscription?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_SubscriptionPaid value)? subscriptionPaid,
    TResult Function(_SubscriptionNotPaid value)? subscriptionNotPaid,
    TResult Function(_PayingSubscription value)? payingSubscription,
    TResult Function(_Failed value)? falied,
    TResult Function(_Success value)? success,
    TResult Function(_SubscriptionStatus value)? subscriptionStatus,
    required TResult orElse(),
  }) {
    if (payingSubscription != null) {
      return payingSubscription(this);
    }
    return orElse();
  }
}

abstract class _PayingSubscription implements SubscriptionState {
  const factory _PayingSubscription(final String paymentLink) =
      _$PayingSubscriptionImpl;

  String get paymentLink;
  @JsonKey(ignore: true)
  _$$PayingSubscriptionImplCopyWith<_$PayingSubscriptionImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FailedImplCopyWith<$Res> {
  factory _$$FailedImplCopyWith(
          _$FailedImpl value, $Res Function(_$FailedImpl) then) =
      __$$FailedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({SubscriptionCheckStatus failed});
}

/// @nodoc
class __$$FailedImplCopyWithImpl<$Res>
    extends _$SubscriptionStateCopyWithImpl<$Res, _$FailedImpl>
    implements _$$FailedImplCopyWith<$Res> {
  __$$FailedImplCopyWithImpl(
      _$FailedImpl _value, $Res Function(_$FailedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failed = null,
  }) {
    return _then(_$FailedImpl(
      null == failed
          ? _value.failed
          : failed // ignore: cast_nullable_to_non_nullable
              as SubscriptionCheckStatus,
    ));
  }
}

/// @nodoc

class _$FailedImpl implements _Failed {
  const _$FailedImpl(this.failed);

  @override
  final SubscriptionCheckStatus failed;

  @override
  String toString() {
    return 'SubscriptionState.falied(failed: $failed)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FailedImpl &&
            (identical(other.failed, failed) || other.failed == failed));
  }

  @override
  int get hashCode => Object.hash(runtimeType, failed);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FailedImplCopyWith<_$FailedImpl> get copyWith =>
      __$$FailedImplCopyWithImpl<_$FailedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<Tariff> tariffs) initial,
    required TResult Function() loading,
    required TResult Function() subscriptionPaid,
    required TResult Function() subscriptionNotPaid,
    required TResult Function(String paymentLink) payingSubscription,
    required TResult Function(SubscriptionCheckStatus failed) falied,
    required TResult Function(SubscriptionCheckStatus success) success,
    required TResult Function(bool isActive, String date) subscriptionStatus,
  }) {
    return falied(failed);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<Tariff> tariffs)? initial,
    TResult? Function()? loading,
    TResult? Function()? subscriptionPaid,
    TResult? Function()? subscriptionNotPaid,
    TResult? Function(String paymentLink)? payingSubscription,
    TResult? Function(SubscriptionCheckStatus failed)? falied,
    TResult? Function(SubscriptionCheckStatus success)? success,
    TResult? Function(bool isActive, String date)? subscriptionStatus,
  }) {
    return falied?.call(failed);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<Tariff> tariffs)? initial,
    TResult Function()? loading,
    TResult Function()? subscriptionPaid,
    TResult Function()? subscriptionNotPaid,
    TResult Function(String paymentLink)? payingSubscription,
    TResult Function(SubscriptionCheckStatus failed)? falied,
    TResult Function(SubscriptionCheckStatus success)? success,
    TResult Function(bool isActive, String date)? subscriptionStatus,
    required TResult orElse(),
  }) {
    if (falied != null) {
      return falied(failed);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_SubscriptionPaid value) subscriptionPaid,
    required TResult Function(_SubscriptionNotPaid value) subscriptionNotPaid,
    required TResult Function(_PayingSubscription value) payingSubscription,
    required TResult Function(_Failed value) falied,
    required TResult Function(_Success value) success,
    required TResult Function(_SubscriptionStatus value) subscriptionStatus,
  }) {
    return falied(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_SubscriptionPaid value)? subscriptionPaid,
    TResult? Function(_SubscriptionNotPaid value)? subscriptionNotPaid,
    TResult? Function(_PayingSubscription value)? payingSubscription,
    TResult? Function(_Failed value)? falied,
    TResult? Function(_Success value)? success,
    TResult? Function(_SubscriptionStatus value)? subscriptionStatus,
  }) {
    return falied?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_SubscriptionPaid value)? subscriptionPaid,
    TResult Function(_SubscriptionNotPaid value)? subscriptionNotPaid,
    TResult Function(_PayingSubscription value)? payingSubscription,
    TResult Function(_Failed value)? falied,
    TResult Function(_Success value)? success,
    TResult Function(_SubscriptionStatus value)? subscriptionStatus,
    required TResult orElse(),
  }) {
    if (falied != null) {
      return falied(this);
    }
    return orElse();
  }
}

abstract class _Failed implements SubscriptionState {
  const factory _Failed(final SubscriptionCheckStatus failed) = _$FailedImpl;

  SubscriptionCheckStatus get failed;
  @JsonKey(ignore: true)
  _$$FailedImplCopyWith<_$FailedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SuccessImplCopyWith<$Res> {
  factory _$$SuccessImplCopyWith(
          _$SuccessImpl value, $Res Function(_$SuccessImpl) then) =
      __$$SuccessImplCopyWithImpl<$Res>;
  @useResult
  $Res call({SubscriptionCheckStatus success});
}

/// @nodoc
class __$$SuccessImplCopyWithImpl<$Res>
    extends _$SubscriptionStateCopyWithImpl<$Res, _$SuccessImpl>
    implements _$$SuccessImplCopyWith<$Res> {
  __$$SuccessImplCopyWithImpl(
      _$SuccessImpl _value, $Res Function(_$SuccessImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? success = null,
  }) {
    return _then(_$SuccessImpl(
      null == success
          ? _value.success
          : success // ignore: cast_nullable_to_non_nullable
              as SubscriptionCheckStatus,
    ));
  }
}

/// @nodoc

class _$SuccessImpl implements _Success {
  const _$SuccessImpl(this.success);

  @override
  final SubscriptionCheckStatus success;

  @override
  String toString() {
    return 'SubscriptionState.success(success: $success)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SuccessImpl &&
            (identical(other.success, success) || other.success == success));
  }

  @override
  int get hashCode => Object.hash(runtimeType, success);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SuccessImplCopyWith<_$SuccessImpl> get copyWith =>
      __$$SuccessImplCopyWithImpl<_$SuccessImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<Tariff> tariffs) initial,
    required TResult Function() loading,
    required TResult Function() subscriptionPaid,
    required TResult Function() subscriptionNotPaid,
    required TResult Function(String paymentLink) payingSubscription,
    required TResult Function(SubscriptionCheckStatus failed) falied,
    required TResult Function(SubscriptionCheckStatus success) success,
    required TResult Function(bool isActive, String date) subscriptionStatus,
  }) {
    return success(this.success);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<Tariff> tariffs)? initial,
    TResult? Function()? loading,
    TResult? Function()? subscriptionPaid,
    TResult? Function()? subscriptionNotPaid,
    TResult? Function(String paymentLink)? payingSubscription,
    TResult? Function(SubscriptionCheckStatus failed)? falied,
    TResult? Function(SubscriptionCheckStatus success)? success,
    TResult? Function(bool isActive, String date)? subscriptionStatus,
  }) {
    return success?.call(this.success);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<Tariff> tariffs)? initial,
    TResult Function()? loading,
    TResult Function()? subscriptionPaid,
    TResult Function()? subscriptionNotPaid,
    TResult Function(String paymentLink)? payingSubscription,
    TResult Function(SubscriptionCheckStatus failed)? falied,
    TResult Function(SubscriptionCheckStatus success)? success,
    TResult Function(bool isActive, String date)? subscriptionStatus,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(this.success);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_SubscriptionPaid value) subscriptionPaid,
    required TResult Function(_SubscriptionNotPaid value) subscriptionNotPaid,
    required TResult Function(_PayingSubscription value) payingSubscription,
    required TResult Function(_Failed value) falied,
    required TResult Function(_Success value) success,
    required TResult Function(_SubscriptionStatus value) subscriptionStatus,
  }) {
    return success(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_SubscriptionPaid value)? subscriptionPaid,
    TResult? Function(_SubscriptionNotPaid value)? subscriptionNotPaid,
    TResult? Function(_PayingSubscription value)? payingSubscription,
    TResult? Function(_Failed value)? falied,
    TResult? Function(_Success value)? success,
    TResult? Function(_SubscriptionStatus value)? subscriptionStatus,
  }) {
    return success?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_SubscriptionPaid value)? subscriptionPaid,
    TResult Function(_SubscriptionNotPaid value)? subscriptionNotPaid,
    TResult Function(_PayingSubscription value)? payingSubscription,
    TResult Function(_Failed value)? falied,
    TResult Function(_Success value)? success,
    TResult Function(_SubscriptionStatus value)? subscriptionStatus,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(this);
    }
    return orElse();
  }
}

abstract class _Success implements SubscriptionState {
  const factory _Success(final SubscriptionCheckStatus success) = _$SuccessImpl;

  SubscriptionCheckStatus get success;
  @JsonKey(ignore: true)
  _$$SuccessImplCopyWith<_$SuccessImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SubscriptionStatusImplCopyWith<$Res> {
  factory _$$SubscriptionStatusImplCopyWith(_$SubscriptionStatusImpl value,
          $Res Function(_$SubscriptionStatusImpl) then) =
      __$$SubscriptionStatusImplCopyWithImpl<$Res>;
  @useResult
  $Res call({bool isActive, String date});
}

/// @nodoc
class __$$SubscriptionStatusImplCopyWithImpl<$Res>
    extends _$SubscriptionStateCopyWithImpl<$Res, _$SubscriptionStatusImpl>
    implements _$$SubscriptionStatusImplCopyWith<$Res> {
  __$$SubscriptionStatusImplCopyWithImpl(_$SubscriptionStatusImpl _value,
      $Res Function(_$SubscriptionStatusImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isActive = null,
    Object? date = null,
  }) {
    return _then(_$SubscriptionStatusImpl(
      null == isActive
          ? _value.isActive
          : isActive // ignore: cast_nullable_to_non_nullable
              as bool,
      null == date
          ? _value.date
          : date // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$SubscriptionStatusImpl implements _SubscriptionStatus {
  const _$SubscriptionStatusImpl(this.isActive, this.date);

  @override
  final bool isActive;
  @override
  final String date;

  @override
  String toString() {
    return 'SubscriptionState.subscriptionStatus(isActive: $isActive, date: $date)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SubscriptionStatusImpl &&
            (identical(other.isActive, isActive) ||
                other.isActive == isActive) &&
            (identical(other.date, date) || other.date == date));
  }

  @override
  int get hashCode => Object.hash(runtimeType, isActive, date);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SubscriptionStatusImplCopyWith<_$SubscriptionStatusImpl> get copyWith =>
      __$$SubscriptionStatusImplCopyWithImpl<_$SubscriptionStatusImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<Tariff> tariffs) initial,
    required TResult Function() loading,
    required TResult Function() subscriptionPaid,
    required TResult Function() subscriptionNotPaid,
    required TResult Function(String paymentLink) payingSubscription,
    required TResult Function(SubscriptionCheckStatus failed) falied,
    required TResult Function(SubscriptionCheckStatus success) success,
    required TResult Function(bool isActive, String date) subscriptionStatus,
  }) {
    return subscriptionStatus(isActive, date);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<Tariff> tariffs)? initial,
    TResult? Function()? loading,
    TResult? Function()? subscriptionPaid,
    TResult? Function()? subscriptionNotPaid,
    TResult? Function(String paymentLink)? payingSubscription,
    TResult? Function(SubscriptionCheckStatus failed)? falied,
    TResult? Function(SubscriptionCheckStatus success)? success,
    TResult? Function(bool isActive, String date)? subscriptionStatus,
  }) {
    return subscriptionStatus?.call(isActive, date);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<Tariff> tariffs)? initial,
    TResult Function()? loading,
    TResult Function()? subscriptionPaid,
    TResult Function()? subscriptionNotPaid,
    TResult Function(String paymentLink)? payingSubscription,
    TResult Function(SubscriptionCheckStatus failed)? falied,
    TResult Function(SubscriptionCheckStatus success)? success,
    TResult Function(bool isActive, String date)? subscriptionStatus,
    required TResult orElse(),
  }) {
    if (subscriptionStatus != null) {
      return subscriptionStatus(isActive, date);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_SubscriptionPaid value) subscriptionPaid,
    required TResult Function(_SubscriptionNotPaid value) subscriptionNotPaid,
    required TResult Function(_PayingSubscription value) payingSubscription,
    required TResult Function(_Failed value) falied,
    required TResult Function(_Success value) success,
    required TResult Function(_SubscriptionStatus value) subscriptionStatus,
  }) {
    return subscriptionStatus(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_SubscriptionPaid value)? subscriptionPaid,
    TResult? Function(_SubscriptionNotPaid value)? subscriptionNotPaid,
    TResult? Function(_PayingSubscription value)? payingSubscription,
    TResult? Function(_Failed value)? falied,
    TResult? Function(_Success value)? success,
    TResult? Function(_SubscriptionStatus value)? subscriptionStatus,
  }) {
    return subscriptionStatus?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_SubscriptionPaid value)? subscriptionPaid,
    TResult Function(_SubscriptionNotPaid value)? subscriptionNotPaid,
    TResult Function(_PayingSubscription value)? payingSubscription,
    TResult Function(_Failed value)? falied,
    TResult Function(_Success value)? success,
    TResult Function(_SubscriptionStatus value)? subscriptionStatus,
    required TResult orElse(),
  }) {
    if (subscriptionStatus != null) {
      return subscriptionStatus(this);
    }
    return orElse();
  }
}

abstract class _SubscriptionStatus implements SubscriptionState {
  const factory _SubscriptionStatus(final bool isActive, final String date) =
      _$SubscriptionStatusImpl;

  bool get isActive;
  String get date;
  @JsonKey(ignore: true)
  _$$SubscriptionStatusImplCopyWith<_$SubscriptionStatusImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
